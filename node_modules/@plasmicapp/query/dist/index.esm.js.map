{
  "version": 3,
  "sources": ["../src/query-data.tsx", "../src/index.tsx"],
  "sourcesContent": ["import React, { PropsWithChildren } from \"react\";\nimport useSWR, {\n  Fetcher,\n  Key,\n  SWRConfig,\n  SWRConfiguration,\n  SWRResponse,\n  useSWRConfig,\n} from \"swr\";\n\nexport type { SWRResponse } from \"swr\";\n\nlet __SWRConfig: ReturnType<typeof useSWRConfig> | undefined = undefined;\nexport const mutateKeys = (invalidateKey?: string) => {\n  if (__SWRConfig) {\n    const { cache, mutate } = __SWRConfig;\n    (invalidateKey != null\n      ? [invalidateKey]\n      : Array.from((cache as Map<string, any>).keys())\n    ).forEach((key) => {\n      mutate(key);\n    });\n  }\n};\n\n// @plasmicapp/query is optimized for SSR, so we do not revalidate\n// automatically upon hydration; as if the data is immutable.\nfunction getPlasmicDefaultSWROptions(opts?: {\n  isMutable?: boolean;\n}): SWRConfiguration {\n  return {\n    revalidateIfStale: !!opts?.isMutable,\n    revalidateOnFocus: false,\n    revalidateOnReconnect: false,\n  };\n}\n\n/**\n * Fetches data asynchronously. This data should be considered immutable for the\n * session -- there is no way to invalidate or re-fetch this data.\n *\n * @param key a unique key for this data fetch; if data already exists under this\n *   key, that data is returned immediately.\n * @param fetcher an async function that resolves to the fetched data.\n * @returns an object with either a \"data\" key with the fetched data if the fetch\n *   was successful, or an \"error\" key with the thrown Error if the fetch failed.\n */\nexport function usePlasmicQueryData<T>(\n  key: Key,\n  fetcher: Fetcher<T>\n): { data?: T; error?: Error; isLoading?: boolean } {\n  const prepassCtx = React.useContext(PrepassContext);\n\n  const opts = getPlasmicDefaultSWROptions();\n  if (prepassCtx) {\n    // If we're doing prepass, then we are always in suspense mode, because\n    // react-ssr-prepass only works with suspense-throwing data fetching.\n    opts.suspense = true;\n  }\n\n  const config = useSWRConfig();\n  React.useEffect(() => {\n    __SWRConfig = config;\n  }, [config]);\n\n  const wrappedFetcher = React.useMemo(\n    () => wrapLoadingFetcher(fetcher),\n    [fetcher]\n  );\n\n  const resp = useSWR(key, wrappedFetcher, opts);\n  if (resp.data !== undefined) {\n    return { data: resp.data };\n  } else if (resp.error) {\n    return { error: resp.error };\n  } else {\n    return { isLoading: true };\n  }\n}\n\n/**\n * Fetches data asynchronously using SWR Hook (https://swr.vercel.app/)\n *\n * @param key a unique key for this data fetch; if data already exists under this\n *   key, that data is returned immediately.\n * @param fetcher an async function that resolves to the fetched data.\n * @param options (optional) an object of options for this hook (https://swr.vercel.app/docs/options).\n * @returns an object with either a \"data\" key with the fetched data if the fetch\n *   was successful, or an \"error\" key with the thrown Error if the fetch failed.\n */\nexport function useMutablePlasmicQueryData<T, E>(\n  key: Key,\n  fetcher: Fetcher<T>,\n  options?: SWRConfiguration<T, E>\n): SWRResponse<T, E> & { isLoading?: boolean; isLagging?: boolean } {\n  const prepassCtx = React.useContext(PrepassContext);\n\n  const opts = {\n    ...getPlasmicDefaultSWROptions({ isMutable: true }),\n    ...options,\n  };\n  if (prepassCtx) {\n    opts.suspense = true;\n  }\n\n  const config = useSWRConfig();\n  React.useEffect(() => {\n    __SWRConfig = config;\n  }, [config]);\n\n  const [isLoading, setIsLoading] = React.useState(false);\n  const fetcherWrapper = React.useCallback(\n    async (...args: any[]) => {\n      setIsLoading(true);\n      try {\n        return await wrapLoadingFetcher(fetcher)(...args);\n      } finally {\n        setIsLoading(false);\n      }\n    },\n    [fetcher]\n  );\n\n  // Based on https://swr.vercel.app/docs/middleware#keep-previous-result\n  const laggyDataRef = React.useRef<any>();\n\n  const { isValidating, mutate, data, error } = useSWR(\n    key,\n    fetcherWrapper,\n    opts\n  );\n\n  React.useEffect(() => {\n    if (data !== undefined) {\n      laggyDataRef.current = data;\n    }\n  }, [data]);\n\n  return React.useMemo(\n    () => ({\n      isValidating,\n      mutate,\n      isLoading: (data === undefined && error === undefined) || isLoading,\n      ...(data !== undefined\n        ? { data }\n        : error === undefined && laggyDataRef.current\n        ? // Show previous data if available\n          { data: laggyDataRef.current, isLagging: true }\n        : {}),\n      ...(error !== undefined ? { error } : {}),\n    }),\n    [isValidating, mutate, data, error, isLoading]\n  );\n}\n\nexport function PlasmicQueryDataProvider(props: {\n  suspense?: boolean;\n  children: React.ReactNode;\n  prefetchedCache?: Record<string, any>;\n}) {\n  const { children, suspense, prefetchedCache } = props;\n  const prepass = React.useContext(PrepassContext);\n  if (prepass) {\n    // If we're in prepass, then there's already a wrappign SWRConfig;\n    // don't interfere with it.\n    return <>{children}</>;\n  } else {\n    return (\n      <SWRConfig\n        value={{\n          fallback: prefetchedCache ?? {},\n          suspense,\n        }}\n      >\n        {children}\n      </SWRConfig>\n    );\n  }\n}\n\nconst PrepassContext = React.createContext<boolean>(false);\n\nexport function PlasmicPrepassContext(\n  props: PropsWithChildren<{\n    cache: Map<string, any>;\n  }>\n) {\n  const { cache, children } = props;\n  return (\n    <PrepassContext.Provider value={true}>\n      <SWRConfig\n        value={{\n          provider: () => cache,\n          suspense: true,\n          fallback: {},\n        }}\n      >\n        {children}\n      </SWRConfig>\n    </PrepassContext.Provider>\n  );\n}\n\nexport const usePlasmicDataConfig: typeof useSWRConfig = useSWRConfig;\n\nlet loadingCount = 0;\nexport type LoadingStateListener = (isLoading: boolean) => void;\nconst listeners: LoadingStateListener[] = [];\n\n/**\n * Subscribes to whether any loading is happening via @plasmicapp/query.\n * Returns a function to unsubscribe.\n */\nexport function addLoadingStateListener(\n  listener: LoadingStateListener,\n  opts?: { immediate?: boolean }\n) {\n  listeners.push(listener);\n  if (opts?.immediate) {\n    listener(loadingCount > 0);\n  }\n  return () => {\n    listeners.splice(listeners.indexOf(listener), 1);\n  };\n}\n\n/**\n * Instruments an async function to increment and decrement the number of\n * simultaneous async loads. You can then subscribe to whether there\n * are any loads happening via addLoadingStateListener().\n */\nexport function wrapLoadingFetcher<\n  T extends (...args: any[]) => Promise<any> | any\n>(fetcher: T): T {\n  return (async (...args: any) => {\n    if (loadingCount === 0) {\n      listeners.forEach((listener) => listener(true));\n    }\n    loadingCount += 1;\n    try {\n      const res = fetcher(...args);\n      return isPromiseLike(res) ? await res : res;\n    } finally {\n      loadingCount -= 1;\n      if (loadingCount === 0) {\n        listeners.forEach((listener) => listener(false));\n      }\n    }\n  }) as T;\n}\n\nfunction isPromiseLike(x: any) {\n  return (\n    !!x && typeof x === \"object\" && \"then\" in x && typeof x.then === \"function\"\n  );\n}\n\nexport function isPlasmicPrepass() {\n  return !!(React as any).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n    ?.ReactCurrentDispatcher?.current?.isPlasmicPrepass;\n}\n\nexport type HeadMetadata = {\n  title?: string;\n  description?: string;\n  image?: string;\n  canonical?: string;\n};\n\nexport const HeadMetadataContext = React.createContext<HeadMetadata>({});\n", "import { mutateKeys } from \"./query-data\";\nexport { useSWRConfig } from \"swr\";\nexport {\n  addLoadingStateListener,\n  HeadMetadataContext,\n  isPlasmicPrepass,\n  PlasmicPrepassContext,\n  PlasmicQueryDataProvider,\n  useMutablePlasmicQueryData,\n  usePlasmicDataConfig,\n  usePlasmicQueryData,\n  wrapLoadingFetcher,\n} from \"./query-data\";\nexport type {\n  HeadMetadata,\n  LoadingStateListener,\n  SWRResponse,\n} from \"./query-data\";\n\nif (typeof window !== \"undefined\") {\n  const root = window as any;\n  const maybeExistingMutateAllKeys = root.__SWRMutateAllKeys;\n  root.__SWRMutateAllKeys = (invalidateKey?: string) => {\n    mutateKeys(invalidateKey);\n    if (typeof maybeExistingMutateAllKeys === \"function\") {\n      maybeExistingMutateAllKeys(invalidateKey);\n    }\n  };\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAO,WAAkC;AACzC,OAAO;AAAA,EAGL;AAAA,EAGA;AAAA,OACK;AAIP,IAAI,cAA2D;AACxD,IAAM,aAAa,CAAC,kBAA2B;AACpD,MAAI,aAAa;AACf,UAAM,EAAE,OAAO,OAAO,IAAI;AAC1B,KAAC,iBAAiB,OACd,CAAC,aAAa,IACd,MAAM,KAAM,MAA2B,KAAK,CAAC,GAC/C,QAAQ,CAAC,QAAQ;AACjB,aAAO,GAAG;AAAA,IACZ,CAAC;AAAA,EACH;AACF;AAIA,SAAS,4BAA4B,MAEhB;AACnB,SAAO;AAAA,IACL,mBAAmB,CAAC,EAAC,6BAAM;AAAA,IAC3B,mBAAmB;AAAA,IACnB,uBAAuB;AAAA,EACzB;AACF;AAYO,SAAS,oBACd,KACA,SACkD;AAClD,QAAM,aAAa,MAAM,WAAW,cAAc;AAElD,QAAM,OAAO,4BAA4B;AACzC,MAAI,YAAY;AAGd,SAAK,WAAW;AAAA,EAClB;AAEA,QAAM,SAAS,aAAa;AAC5B,QAAM,UAAU,MAAM;AACpB,kBAAc;AAAA,EAChB,GAAG,CAAC,MAAM,CAAC;AAEX,QAAM,iBAAiB,MAAM;AAAA,IAC3B,MAAM,mBAAmB,OAAO;AAAA,IAChC,CAAC,OAAO;AAAA,EACV;AAEA,QAAM,OAAO,OAAO,KAAK,gBAAgB,IAAI;AAC7C,MAAI,KAAK,SAAS,QAAW;AAC3B,WAAO,EAAE,MAAM,KAAK,KAAK;AAAA,EAC3B,WAAW,KAAK,OAAO;AACrB,WAAO,EAAE,OAAO,KAAK,MAAM;AAAA,EAC7B,OAAO;AACL,WAAO,EAAE,WAAW,KAAK;AAAA,EAC3B;AACF;AAYO,SAAS,2BACd,KACA,SACA,SACkE;AAClE,QAAM,aAAa,MAAM,WAAW,cAAc;AAElD,QAAM,OAAO,kCACR,4BAA4B,EAAE,WAAW,KAAK,CAAC,IAC/C;AAEL,MAAI,YAAY;AACd,SAAK,WAAW;AAAA,EAClB;AAEA,QAAM,SAAS,aAAa;AAC5B,QAAM,UAAU,MAAM;AACpB,kBAAc;AAAA,EAChB,GAAG,CAAC,MAAM,CAAC;AAEX,QAAM,CAAC,WAAW,YAAY,IAAI,MAAM,SAAS,KAAK;AACtD,QAAM,iBAAiB,MAAM;AAAA,IAC3B,IAAU,SAAgB;AACxB,mBAAa,IAAI;AACjB,UAAI;AACF,eAAO,MAAM,mBAAmB,OAAO,EAAE,GAAG,IAAI;AAAA,MAClD,UAAE;AACA,qBAAa,KAAK;AAAA,MACpB;AAAA,IACF;AAAA,IACA,CAAC,OAAO;AAAA,EACV;AAGA,QAAM,eAAe,MAAM,OAAY;AAEvC,QAAM,EAAE,cAAc,QAAQ,MAAM,MAAM,IAAI;AAAA,IAC5C;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,QAAM,UAAU,MAAM;AACpB,QAAI,SAAS,QAAW;AACtB,mBAAa,UAAU;AAAA,IACzB;AAAA,EACF,GAAG,CAAC,IAAI,CAAC;AAET,SAAO,MAAM;AAAA,IACX,MAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA,WAAY,SAAS,UAAa,UAAU,UAAc;AAAA,OACtD,SAAS,SACT,EAAE,KAAK,IACP,UAAU,UAAa,aAAa;AAAA;AAAA,MAEpC,EAAE,MAAM,aAAa,SAAS,WAAW,KAAK;AAAA,QAC9C,CAAC,IACD,UAAU,SAAY,EAAE,MAAM,IAAI,CAAC;AAAA,IAEzC,CAAC,cAAc,QAAQ,MAAM,OAAO,SAAS;AAAA,EAC/C;AACF;AAEO,SAAS,yBAAyB,OAItC;AACD,QAAM,EAAE,UAAU,UAAU,gBAAgB,IAAI;AAChD,QAAM,UAAU,MAAM,WAAW,cAAc;AAC/C,MAAI,SAAS;AAGX,WAAO,0DAAG,QAAS;AAAA,EACrB,OAAO;AACL,WACE;AAAA,MAAC;AAAA;AAAA,QACC,OAAO;AAAA,UACL,UAAU,4CAAmB,CAAC;AAAA,UAC9B;AAAA,QACF;AAAA;AAAA,MAEC;AAAA,IACH;AAAA,EAEJ;AACF;AAEA,IAAM,iBAAiB,MAAM,cAAuB,KAAK;AAElD,SAAS,sBACd,OAGA;AACA,QAAM,EAAE,OAAO,SAAS,IAAI;AAC5B,SACE,oCAAC,eAAe,UAAf,EAAwB,OAAO,QAC9B;AAAA,IAAC;AAAA;AAAA,MACC,OAAO;AAAA,QACL,UAAU,MAAM;AAAA,QAChB,UAAU;AAAA,QACV,UAAU,CAAC;AAAA,MACb;AAAA;AAAA,IAEC;AAAA,EACH,CACF;AAEJ;AAEO,IAAM,uBAA4C;AAEzD,IAAI,eAAe;AAEnB,IAAM,YAAoC,CAAC;AAMpC,SAAS,wBACd,UACA,MACA;AACA,YAAU,KAAK,QAAQ;AACvB,MAAI,6BAAM,WAAW;AACnB,aAAS,eAAe,CAAC;AAAA,EAC3B;AACA,SAAO,MAAM;AACX,cAAU,OAAO,UAAU,QAAQ,QAAQ,GAAG,CAAC;AAAA,EACjD;AACF;AAOO,SAAS,mBAEd,SAAe;AACf,SAAQ,IAAU,SAAc;AAC9B,QAAI,iBAAiB,GAAG;AACtB,gBAAU,QAAQ,CAAC,aAAa,SAAS,IAAI,CAAC;AAAA,IAChD;AACA,oBAAgB;AAChB,QAAI;AACF,YAAM,MAAM,QAAQ,GAAG,IAAI;AAC3B,aAAO,cAAc,GAAG,IAAI,MAAM,MAAM;AAAA,IAC1C,UAAE;AACA,sBAAgB;AAChB,UAAI,iBAAiB,GAAG;AACtB,kBAAU,QAAQ,CAAC,aAAa,SAAS,KAAK,CAAC;AAAA,MACjD;AAAA,IACF;AAAA,EACF;AACF;AAEA,SAAS,cAAc,GAAQ;AAC7B,SACE,CAAC,CAAC,KAAK,OAAO,MAAM,YAAY,UAAU,KAAK,OAAO,EAAE,SAAS;AAErE;AAEO,SAAS,mBAAmB;AAjQnC;AAkQE,SAAO,CAAC,GAAE,uBAAc,uDAAd,mBACN,2BADM,mBACkB,YADlB,mBAC2B;AACvC;AASO,IAAM,sBAAsB,MAAM,cAA4B,CAAC,CAAC;;;AC5QvE,SAAS,gBAAAA,qBAAoB;AAkB7B,IAAI,OAAO,WAAW,aAAa;AACjC,QAAM,OAAO;AACb,QAAM,6BAA6B,KAAK;AACxC,OAAK,qBAAqB,CAAC,kBAA2B;AACpD,eAAW,aAAa;AACxB,QAAI,OAAO,+BAA+B,YAAY;AACpD,iCAA2B,aAAa;AAAA,IAC1C;AAAA,EACF;AACF;",
  "names": ["useSWRConfig"]
}
