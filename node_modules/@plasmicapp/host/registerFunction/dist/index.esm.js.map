{"version":3,"file":"index.esm.js","sources":["../../src/registerFunction.ts"],"sourcesContent":["const root = globalThis as any;\n\nexport type StringType<T extends string = string> = \"string\" | `'${T}'`;\n\nexport type NumberType<T extends number = number> =\n  | \"number\"\n  | `${number extends T ? number : T}`;\n\nexport type BooleanType<T extends boolean = boolean> =\n  | \"boolean\"\n  | `${boolean extends T ? boolean : T}`;\n\nexport type NullType = \"null\";\n\nexport type UndefinedType = \"undefined\";\n\nexport type ArrayType = \"array\";\n\nexport type ObjectType = \"object\";\n\nexport type AnyType = \"any\";\n\nexport type VoidType = \"void\";\n\nexport type RestrictedType<T> = T extends string\n  ? StringType<T>\n  : T extends number\n  ? NumberType<T>\n  : T extends boolean\n  ? BooleanType<T>\n  : T extends null\n  ? NullType\n  : T extends undefined\n  ? UndefinedType\n  : T extends Array<any>\n  ? ArrayType\n  : T extends object\n  ? ObjectType\n  : AnyType;\n\nexport type OrType<T> = RestrictedType<T>[];\n\nexport type ParamType<T> = AnyType | RestrictedType<T> | OrType<T>;\n\nexport interface BaseParam<T> {\n  name: string;\n  type?: ParamType<T>;\n  description?: string;\n  isOptional?: boolean;\n  isRestParam?: boolean;\n}\n\n// Param name and optionally param type\nexport interface RequiredParam<T> extends BaseParam<T> {\n  isOptional?: false;\n  isRestParameter?: false;\n}\n\nexport interface OptionalParam<T> extends BaseParam<T | undefined> {\n  isRestParameter?: false;\n}\n\nexport interface RestParam<T> extends BaseParam<T> {\n  isOptional?: false;\n  isRestParameter: true;\n}\n\n// https://stackoverflow.com/questions/70684030/remove-all-optional-items-from-a-tuple-type\ntype RequiredParams<\n  T extends any[],\n  U extends any[] = []\n> = Partial<T> extends T\n  ? U\n  : T extends [infer F, ...infer R]\n  ? RequiredParams<R, [...U, F]>\n  : U;\n\ntype OptionalParams<T extends any[]> = T extends [\n  ...RequiredParams<T>,\n  ...infer R\n]\n  ? [...R]\n  : [];\n\ntype HandleRequiredParams<P extends any[]> = P extends [infer H, ...infer T]\n  ? [string | RequiredParam<H>, ...HandleRequiredParams<T>]\n  : [];\n\ntype HandleOptionalParams<P extends any[]> = P extends [infer H, ...infer T]\n  ? [] | [string | OptionalParam<H | undefined>, ...HandleOptionalParams<T>]\n  : P extends []\n  ? []\n  : P extends Array<infer T>\n  ? [] | [RestParam<T[]>]\n  : [];\n\nexport type HandleParams<P extends any[]> = [\n  ...HandleRequiredParams<RequiredParams<P>>,\n  ...HandleOptionalParams<Required<OptionalParams<P>>>\n];\n\nexport type HandleReturnType<T> = VoidType | ParamType<T>;\n\nexport interface CustomFunctionMeta<F extends (...args: any[]) => any> {\n  /**\n   * The javascript name of the function. Notice it must be unique across all\n   * other functions and function namespaces. If two functions have the same\n   * name, they should be registered with different `meta.namespace`.\n   */\n  name: string;\n  /**\n   * A namespace for organizing groups of functions. It's also used to handle\n   * function name collisions. If a function has a namespace, it will be used\n   * whenever accessing the function.\n   */\n  namespace?: string;\n  /**\n   * Documentation for the registered function.\n   */\n  description?: string;\n  /**\n   * An array containing the list of parameters names the function takes.\n   * Optionally they can also be registered with the expected param types.\n   */\n  params?: HandleParams<Parameters<F>>;\n  /**\n   * Return value information.\n   */\n  returnValue?: {\n    /**\n     * The function return type.\n     */\n    type?: HandleReturnType<ReturnType<F>>;\n    /**\n     * The function return value description.\n     */\n    description?: string;\n  };\n  /**\n   * Typescript function declaration. If specified, it ignores the types\n   * provided by `params` and `returnValue`.\n   */\n  typescriptDeclaration?: string;\n  /**\n   * The path to be used when importing the function in the generated code.\n   * It can be the name of the package that contains the function, or the path\n   * to the file in the project (relative to the root directory).\n   */\n  importPath: string;\n  /**\n   * Whether the function is the default export from that path. Optional: if\n   * not specified, it's considered `false`.\n   */\n  isDefaultExport?: boolean;\n}\n\nexport interface CustomFunctionRegistration {\n  function: (...args: any[]) => any;\n  meta: CustomFunctionMeta<any>;\n}\n\ndeclare global {\n  interface Window {\n    __PlasmicFunctionsRegistry: CustomFunctionRegistration[];\n  }\n}\n\nif (root.__PlasmicFunctionsRegistry == null) {\n  root.__PlasmicFunctionsRegistry = [];\n}\n\nexport default function registerFunction<F extends (...args: any[]) => any>(\n  fn: F,\n  meta: CustomFunctionMeta<F>\n) {\n  // Check for duplicates\n  if (\n    root.__PlasmicFunctionsRegistry.some(\n      (r: CustomFunctionRegistration) =>\n        r.function === fn &&\n        r.meta.name === meta.name &&\n        r.meta.namespace == meta.namespace\n    )\n  ) {\n    return;\n  }\n  root.__PlasmicFunctionsRegistry.push({ function: fn, meta });\n}\n"],"names":[],"mappings":";AAAA,IAAM,IAAI,GAAG,UAAiB,CAAC;AAuK/B,IAAI,IAAI,CAAC,0BAA0B,IAAI,IAAI,EAAE;AAC3C,IAAA,IAAI,CAAC,0BAA0B,GAAG,EAAE,CAAC;AACtC,CAAA;AAEa,SAAU,gBAAgB,CACtC,EAAK,EACL,IAA2B,EAAA;;AAG3B,IAAA,IACE,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAClC,UAAC,CAA6B,EAAA;AAC5B,QAAA,OAAA,CAAC,CAAC,QAAQ,KAAK,EAAE;AACjB,YAAA,CAAC,CAAC,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI;AACzB,YAAA,CAAC,CAAC,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,SAAS,CAAA;AAFlC,KAEkC,CACrC,EACD;QACA,OAAO;AACR,KAAA;AACD,IAAA,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAAC,EAAE,QAAQ,EAAE,EAAE,EAAE,IAAI,EAAA,IAAA,EAAE,CAAC,CAAC;AAC/D;;;;"}