{
  "version": 3,
  "sources": ["../src/react-server.ts", "../src/extracted-data-fetcher.ts"],
  "sourcesContent": ["export * from \"./extracted-data-fetcher\";\n", "import type { HeadMetadata } from \"@plasmicapp/query\";\nimport { parse as parseHtml } from \"node-html-parser\";\nimport { Metadata } from \"next\";\n\nexport async function fetchExtractedQueryData(url: string) {\n  const res = await fetch(url);\n  if (res.status !== 200) {\n    return undefined;\n  }\n\n  const html = await res.text();\n  const root = parseHtml(html);\n  const script = root.querySelector(\"script[data-plasmic-prefetch-id]\");\n  if (script) {\n    return JSON.parse(script.innerHTML);\n  }\n  return undefined;\n}\n\nexport async function fetchExtractedHeadMetadata(\n  url: string\n): Promise<HeadMetadata | undefined> {\n  const res = await fetch(url);\n  if (res.status !== 200) {\n    return undefined;\n  }\n\n  const html = await res.text();\n  const root = parseHtml(html);\n  const script = root.querySelector(\"script[data-plasmic-head-metadata-id]\");\n  if (script) {\n    return JSON.parse(script.innerHTML);\n  }\n  return undefined;\n}\n\n/**\n * Helper function to extract Head metadata from Plasmic pages.\n *\n * Given current pathname + search params, returns an object compatible with\n * Next.js Metadata interface with SEO metadata.\n */\nexport async function withPlasmicMetadata({\n  pathname,\n  searchParams,\n}: {\n  pathname: string;\n  searchParams: Record<string, string | string[]> | undefined;\n}): Promise<object> {\n  const isPlasmicSsr =\n    !!searchParams?.[\"plasmicSsr\"] && searchParams?.[\"plasmicSsr\"] !== \"false\";\n\n  if (isPlasmicSsr) {\n    // We're building the metadata for SSR endpoint here; this endpoint is not\n    // exposed for users, so we can just return an empty object.\n    return {};\n  }\n\n  // Fetch the same page from SSR endpoint to retrieve Head metadata\n  const prepassHost =\n    process.env.PLASMIC_PREPASS_HOST ??\n    (process.env.VERCEL_URL && `https://${process.env.VERCEL_URL}`) ??\n    `http://localhost:${process.env.PORT ?? 3000}`;\n\n  // Build a copy of the search params\n  const newSearchParams = new URLSearchParams(\n    Object.entries(searchParams ?? {}).flatMap(([key, values]) =>\n      Array.isArray(values) ? values.map((v) => [key, v]) : [[key, values]]\n    )\n  );\n\n  // Set `plasmicSsr` search param to indicate you are using the SSR endpoint.\n  newSearchParams.set(\"plasmicSsr\", \"true\");\n\n  if (process.env.VERCEL_AUTOMATION_BYPASS_SECRET) {\n    // If protection bypass is enabled, use it to ensure fetching from\n    // the SSR endpoint will not return the authentication page HTML\n    newSearchParams.set(\n      \"x-vercel-protection-bypass\",\n      process.env.VERCEL_AUTOMATION_BYPASS_SECRET\n    );\n  }\n\n  // Fetch and return the data from the endpoint using the new search params\n  const prefetchedHeadMetadata = await fetchExtractedHeadMetadata(\n    `${prepassHost}${pathname}?${newSearchParams.toString()}`\n  );\n\n  // Create metadata object\n  const headMetadata: Metadata = {};\n  if (\n    prefetchedHeadMetadata &&\n    Object.keys(prefetchedHeadMetadata).length > 0\n  ) {\n    if (prefetchedHeadMetadata.image) {\n      headMetadata.twitter = {\n        card: \"summary_large_image\",\n        images: [prefetchedHeadMetadata.image],\n      };\n      headMetadata.openGraph = {\n        images: [prefetchedHeadMetadata.image],\n      };\n    } else {\n      headMetadata.twitter = {\n        card: \"summary\",\n      };\n      headMetadata.openGraph = {};\n    }\n    if (prefetchedHeadMetadata.title) {\n      headMetadata.title = prefetchedHeadMetadata.title;\n      headMetadata.twitter.title = prefetchedHeadMetadata.title;\n      headMetadata.openGraph.title = prefetchedHeadMetadata.title;\n    }\n    if (prefetchedHeadMetadata.description) {\n      headMetadata.description = prefetchedHeadMetadata.description;\n      headMetadata.twitter.description = prefetchedHeadMetadata.description;\n      headMetadata.openGraph.description = prefetchedHeadMetadata.description;\n    }\n    if (prefetchedHeadMetadata.canonical) {\n      headMetadata.alternates = {\n        canonical: prefetchedHeadMetadata.canonical,\n      };\n    }\n  }\n\n  return headMetadata;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACCA,8BAAmC;AAGnC,SAAsB,wBAAwB,KAAa;AAAA;AACzD,UAAM,MAAM,MAAM,MAAM,GAAG;AAC3B,QAAI,IAAI,WAAW,KAAK;AACtB,aAAO;AAAA,IACT;AAEA,UAAM,OAAO,MAAM,IAAI,KAAK;AAC5B,UAAM,WAAO,wBAAAA,OAAU,IAAI;AAC3B,UAAM,SAAS,KAAK,cAAc,kCAAkC;AACpE,QAAI,QAAQ;AACV,aAAO,KAAK,MAAM,OAAO,SAAS;AAAA,IACpC;AACA,WAAO;AAAA,EACT;AAAA;AAEA,SAAsB,2BACpB,KACmC;AAAA;AACnC,UAAM,MAAM,MAAM,MAAM,GAAG;AAC3B,QAAI,IAAI,WAAW,KAAK;AACtB,aAAO;AAAA,IACT;AAEA,UAAM,OAAO,MAAM,IAAI,KAAK;AAC5B,UAAM,WAAO,wBAAAA,OAAU,IAAI;AAC3B,UAAM,SAAS,KAAK,cAAc,uCAAuC;AACzE,QAAI,QAAQ;AACV,aAAO,KAAK,MAAM,OAAO,SAAS;AAAA,IACpC;AACA,WAAO;AAAA,EACT;AAAA;AAQA,SAAsB,oBAAoB,IAMtB;AAAA,6CANsB;AAAA,IACxC;AAAA,IACA;AAAA,EACF,GAGoB;AAhDpB;AAiDE,UAAM,eACJ,CAAC,EAAC,6CAAe,mBAAiB,6CAAe,mBAAkB;AAErE,QAAI,cAAc;AAGhB,aAAO,CAAC;AAAA,IACV;AAGA,UAAM,eACJ,mBAAQ,IAAI,yBAAZ,YACC,QAAQ,IAAI,cAAc,WAAW,QAAQ,IAAI,iBADlD,YAEA,qBAAoB,aAAQ,IAAI,SAAZ,YAAoB;AAG1C,UAAM,kBAAkB,IAAI;AAAA,MAC1B,OAAO,QAAQ,sCAAgB,CAAC,CAAC,EAAE;AAAA,QAAQ,CAAC,CAAC,KAAK,MAAM,MACtD,MAAM,QAAQ,MAAM,IAAI,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,CAAC,KAAK,MAAM,CAAC;AAAA,MACtE;AAAA,IACF;AAGA,oBAAgB,IAAI,cAAc,MAAM;AAExC,QAAI,QAAQ,IAAI,iCAAiC;AAG/C,sBAAgB;AAAA,QACd;AAAA,QACA,QAAQ,IAAI;AAAA,MACd;AAAA,IACF;AAGA,UAAM,yBAAyB,MAAM;AAAA,MACnC,GAAG,cAAc,YAAY,gBAAgB,SAAS;AAAA,IACxD;AAGA,UAAM,eAAyB,CAAC;AAChC,QACE,0BACA,OAAO,KAAK,sBAAsB,EAAE,SAAS,GAC7C;AACA,UAAI,uBAAuB,OAAO;AAChC,qBAAa,UAAU;AAAA,UACrB,MAAM;AAAA,UACN,QAAQ,CAAC,uBAAuB,KAAK;AAAA,QACvC;AACA,qBAAa,YAAY;AAAA,UACvB,QAAQ,CAAC,uBAAuB,KAAK;AAAA,QACvC;AAAA,MACF,OAAO;AACL,qBAAa,UAAU;AAAA,UACrB,MAAM;AAAA,QACR;AACA,qBAAa,YAAY,CAAC;AAAA,MAC5B;AACA,UAAI,uBAAuB,OAAO;AAChC,qBAAa,QAAQ,uBAAuB;AAC5C,qBAAa,QAAQ,QAAQ,uBAAuB;AACpD,qBAAa,UAAU,QAAQ,uBAAuB;AAAA,MACxD;AACA,UAAI,uBAAuB,aAAa;AACtC,qBAAa,cAAc,uBAAuB;AAClD,qBAAa,QAAQ,cAAc,uBAAuB;AAC1D,qBAAa,UAAU,cAAc,uBAAuB;AAAA,MAC9D;AACA,UAAI,uBAAuB,WAAW;AACpC,qBAAa,aAAa;AAAA,UACxB,WAAW,uBAAuB;AAAA,QACpC;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;",
  "names": ["parseHtml"]
}
