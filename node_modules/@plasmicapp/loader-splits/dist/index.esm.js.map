{
  "version": 3,
  "sources": ["../src/random.ts", "../src/variation.ts"],
  "sourcesContent": ["export const getSeededRandomFunction = (strSeed: string) => {\n  // https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript\n  function cyrb128(str: string) {\n    let h1 = 1779033703,\n      h2 = 3144134277,\n      h3 = 1013904242,\n      h4 = 2773480762;\n    for (let i = 0, k; i < str.length; i++) {\n      k = str.charCodeAt(i);\n      h1 = h2 ^ Math.imul(h1 ^ k, 597399067);\n      h2 = h3 ^ Math.imul(h2 ^ k, 2869860233);\n      h3 = h4 ^ Math.imul(h3 ^ k, 951274213);\n      h4 = h1 ^ Math.imul(h4 ^ k, 2716044179);\n    }\n    h1 = Math.imul(h3 ^ (h1 >>> 18), 597399067);\n    h2 = Math.imul(h4 ^ (h2 >>> 22), 2869860233);\n    h3 = Math.imul(h1 ^ (h3 >>> 17), 951274213);\n    h4 = Math.imul(h2 ^ (h4 >>> 19), 2716044179);\n    return [\n      (h1 ^ h2 ^ h3 ^ h4) >>> 0,\n      (h2 ^ h1) >>> 0,\n      (h3 ^ h1) >>> 0,\n      (h4 ^ h1) >>> 0,\n    ];\n  }\n  function sfc32(a: number, b: number, c: number, d: number) {\n    return function () {\n      a >>>= 0;\n      b >>>= 0;\n      c >>>= 0;\n      d >>>= 0;\n      let t = (a + b) | 0;\n      a = b ^ (b >>> 9);\n      b = (c + (c << 3)) | 0;\n      c = (c << 21) | (c >>> 11);\n      d = (d + 1) | 0;\n      t = (t + d) | 0;\n      c = (c + t) | 0;\n      return (t >>> 0) / 4294967296;\n    };\n  }\n  const seed = cyrb128(strSeed);\n  const rand = sfc32(seed[0], seed[1], seed[2], seed[3]);\n  return rand;\n};\n", "import type {\n  ExperimentSlice,\n  SegmentSlice,\n  Split,\n} from \"@plasmicapp/loader-fetcher\";\nimport jsonLogic from \"json-logic-js\";\nimport { getSeededRandomFunction } from \"./random\";\n\nconst isBrowser =\n  typeof window !== \"undefined\" &&\n  window != null &&\n  typeof window.document !== \"undefined\";\n\nconst PLASMIC_SEED = \"plasmic_seed\";\n\nconst BUILTIN_TRAITS_UNKNOWN = {\n  pageUrl: \"unknown\",\n};\n\nconst getBrowserBuiltinTraits = () => {\n  if (!isBrowser) {\n    return {};\n  }\n  return {\n    pageUrl: document.location.href,\n  };\n};\n\nexport const getSplitKey = (split: Split) => {\n  return `${split.type === \"experiment\" ? \"exp.\" : \"seg.\"}${split.id}`;\n};\n\nexport function getActiveVariation(opts: {\n  splits: Split[];\n  traits: Record<string, string | number | boolean>;\n  getKnownValue?: (key: string) => string | undefined;\n  updateKnownValue?: (key: string, value: string) => void;\n  getRandomValue?: (key: string) => number;\n  enableUnseededExperiments?: boolean;\n  useSeedBucketing?: boolean;\n  seedRange?: number;\n}) {\n  const { splits, getKnownValue, updateKnownValue } = opts;\n  const getRandomValue = (key: string) => {\n    if (opts.getRandomValue) {\n      return opts.getRandomValue(key);\n    }\n\n    if (opts.traits[PLASMIC_SEED]) {\n      const rand = getSeededRandomFunction(\n        (opts.traits[PLASMIC_SEED] ?? \"\") + key\n      );\n      return rand();\n    }\n\n    // If we don't have a seed we won't be able to get a consistent variation\n    // in SSR, so we just return 0. Unless if expressly enabled.\n    if (!opts.enableUnseededExperiments) {\n      return 0;\n    }\n\n    return Math.random();\n  };\n  const variation: Record<string, string> = {};\n  splits.forEach((split) => {\n    const key = getSplitKey(split);\n    const knownVal = getKnownValue?.(key);\n    if (knownVal) {\n      variation[key] = knownVal;\n      return;\n    }\n    const numSlices = split.slices.length;\n    let chosenSlice = undefined;\n    if (split.type === \"experiment\") {\n      /**\n       * If useSeedBucketing is enabled, we will use the seed to bucket the user\n       * into a slice. Otherwise, we will use the random value to bucket the user\n       * into a slice.\n       *\n       * By using seed bucketing, we ensure the number of seeds that each slice gets,\n       * is proportional to the slice's probability.\n       */\n      if (opts.useSeedBucketing) {\n        const seed = opts.traits[PLASMIC_SEED];\n        const buckets: string[] = [];\n        const totalBuckets = opts.seedRange ?? 1;\n        let avaiableBuckets = totalBuckets;\n        for (let i = 0; i < numSlices; i++) {\n          const slice = split.slices[i];\n          const numBuckets = Math.min(\n            Math.floor(slice.prob * totalBuckets),\n            avaiableBuckets\n          );\n          for (let j = 0; j < numBuckets; j++) {\n            buckets.push(slice.id);\n          }\n          avaiableBuckets -= numBuckets;\n        }\n        if (buckets.length > 0) {\n          // We need to stable shuffle the buckets to ensure that the order of the\n          // buckets is deterministic.\n          const shuffleRand = getSeededRandomFunction(split.id);\n          for (let i = 0; i < buckets.length; i++) {\n            const j = Math.floor(shuffleRand() * (i + 1));\n            [buckets[i], buckets[j]] = [buckets[j], buckets[i]];\n          }\n          // We use the seed to bucket the user into a slice.\n          const sliceIdx = +(seed ?? \"0\") % buckets.length;\n          chosenSlice = split.slices.find((s) => s.id === buckets[sliceIdx]);\n        } else {\n          chosenSlice = split.slices[numSlices - 1];\n        }\n      } else {\n        let p = getRandomValue(split.id);\n        chosenSlice = split.slices[numSlices - 1];\n        for (let i = 0; i < numSlices; i++) {\n          if (p - split.slices[i].prob <= 0) {\n            chosenSlice = split.slices[i];\n            break;\n          }\n          p -= split.slices[i].prob;\n        }\n      }\n    } else if (split.type === \"segment\") {\n      for (let i = 0; i < numSlices; i++) {\n        if (\n          jsonLogic.apply(split.slices[i].cond, {\n            time: new Date().toISOString(),\n            ...BUILTIN_TRAITS_UNKNOWN,\n            ...getBrowserBuiltinTraits(),\n            ...opts.traits,\n          })\n        ) {\n          chosenSlice = split.slices[i];\n        }\n      }\n    }\n\n    if (chosenSlice) {\n      variation[key] = chosenSlice.id;\n      if (split.externalId && chosenSlice.externalId) {\n        variation[`ext.${split.externalId}`] = chosenSlice.externalId;\n      }\n      if (split.type === \"experiment\") {\n        updateKnownValue?.(key, chosenSlice.id);\n      }\n    }\n  });\n\n  return variation;\n}\n\ninterface ExternalIDsFilters {\n  projectIds?: string[];\n  customFilter?: (split: Split) => boolean;\n}\n\nexport function getExternalIds(\n  splits: Split[],\n  variation: Record<string, string>,\n  filters?: ExternalIDsFilters\n) {\n  const externalVariation: Record<string, string> = {};\n\n  function shouldIncludeSplit(split: Split) {\n    if (!filters) {\n      return true;\n    }\n    if (filters.projectIds && !filters.projectIds.includes(split.projectId)) {\n      return false;\n    }\n    if (filters.customFilter && !filters.customFilter(split)) {\n      return false;\n    }\n    return true;\n  }\n\n  Object.keys(variation).forEach((variationKey) => {\n    const [, splitId] = variationKey.split(\".\");\n    const sliceId = variation[variationKey];\n    const split = splits.find(\n      (s) => s.id === splitId || s.externalId === splitId\n    );\n    if (split && split.externalId && shouldIncludeSplit(split)) {\n      const slice = (\n        split.slices as Array<ExperimentSlice | SegmentSlice>\n      ).find((s) => s.id === sliceId || s.externalId === sliceId);\n      if (slice?.externalId) {\n        // Save variation without ext prefix\n        externalVariation[`${split.externalId}`] = slice.externalId;\n      }\n    }\n  });\n  return externalVariation;\n}\n\nexport interface PickedVariationDescription {\n  name: string;\n  description?: string;\n  pagesPaths: string[];\n  type: \"original\" | \"override\";\n  chosenValue: string;\n  externalIdGroup?: string;\n  externalIdValue?: string;\n}\n\nexport function describeVariationForKey(\n  splits: Split[],\n  key: string,\n  value: string\n): PickedVariationDescription {\n  const [, splitId] = key.split(\".\");\n  const split = splits.find(\n    (s) => s.id === splitId || s.externalId === splitId\n  );\n\n  if (!split) {\n    throw new Error(`Split not found for key \"${key}\"`);\n  }\n\n  const sliceIndex = split.slices.findIndex(\n    (s) => s.id === value || s.externalId === value\n  );\n\n  if (sliceIndex === -1) {\n    throw new Error(`Invalid split value \"${value}\" for key \"${key}\"`);\n  }\n\n  return {\n    name: split.name,\n    description: split.description,\n    pagesPaths: split.pagesPaths,\n    type: sliceIndex === 0 ? \"original\" : \"override\",\n    chosenValue: value,\n    externalIdGroup: split.externalId,\n    externalIdValue:\n      sliceIndex >= 0 && split.slices[sliceIndex].externalId\n        ? split.slices[sliceIndex].externalId\n        : undefined,\n  };\n}\n\n/**\n * Gets a more human-readable description of the variation\n */\nexport function describeVariation(\n  splits: Split[],\n  variation: Record<string, string>\n): Record<string, PickedVariationDescription> {\n  return Object.fromEntries(\n    Object.entries(variation).map(([key, value]) => {\n      return [key, describeVariationForKey(splits, key, value)];\n    })\n  );\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAO,IAAM,0BAA0B,CAAC,YAAoB;AAE1D,WAAS,QAAQ,KAAa;AAC5B,QAAI,KAAK,YACP,KAAK,YACL,KAAK,YACL,KAAK;AACP,aAAS,IAAI,GAAG,GAAG,IAAI,IAAI,QAAQ,KAAK;AACtC,UAAI,IAAI,WAAW,CAAC;AACpB,WAAK,KAAK,KAAK,KAAK,KAAK,GAAG,SAAS;AACrC,WAAK,KAAK,KAAK,KAAK,KAAK,GAAG,UAAU;AACtC,WAAK,KAAK,KAAK,KAAK,KAAK,GAAG,SAAS;AACrC,WAAK,KAAK,KAAK,KAAK,KAAK,GAAG,UAAU;AAAA,IACxC;AACA,SAAK,KAAK,KAAK,KAAM,OAAO,IAAK,SAAS;AAC1C,SAAK,KAAK,KAAK,KAAM,OAAO,IAAK,UAAU;AAC3C,SAAK,KAAK,KAAK,KAAM,OAAO,IAAK,SAAS;AAC1C,SAAK,KAAK,KAAK,KAAM,OAAO,IAAK,UAAU;AAC3C,WAAO;AAAA,OACJ,KAAK,KAAK,KAAK,QAAQ;AAAA,OACvB,KAAK,QAAQ;AAAA,OACb,KAAK,QAAQ;AAAA,OACb,KAAK,QAAQ;AAAA,IAChB;AAAA,EACF;AACA,WAAS,MAAM,GAAW,GAAW,GAAW,GAAW;AACzD,WAAO,WAAY;AACjB,aAAO;AACP,aAAO;AACP,aAAO;AACP,aAAO;AACP,UAAI,IAAK,IAAI,IAAK;AAClB,UAAI,IAAK,MAAM;AACf,UAAK,KAAK,KAAK,KAAM;AACrB,UAAK,KAAK,KAAO,MAAM;AACvB,UAAK,IAAI,IAAK;AACd,UAAK,IAAI,IAAK;AACd,UAAK,IAAI,IAAK;AACd,cAAQ,MAAM,KAAK;AAAA,IACrB;AAAA,EACF;AACA,QAAM,OAAO,QAAQ,OAAO;AAC5B,QAAM,OAAO,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;AACrD,SAAO;AACT;;;ACvCA,OAAO,eAAe;AAGtB,IAAM,YACJ,OAAO,WAAW,eAClB,UAAU,QACV,OAAO,OAAO,aAAa;AAE7B,IAAM,eAAe;AAErB,IAAM,yBAAyB;AAAA,EAC7B,SAAS;AACX;AAEA,IAAM,0BAA0B,MAAM;AACpC,MAAI,CAAC,WAAW;AACd,WAAO,CAAC;AAAA,EACV;AACA,SAAO;AAAA,IACL,SAAS,SAAS,SAAS;AAAA,EAC7B;AACF;AAEO,IAAM,cAAc,CAAC,UAAiB;AAC3C,SAAO,GAAG,MAAM,SAAS,eAAe,SAAS,SAAS,MAAM;AAClE;AAEO,SAAS,mBAAmB,MAShC;AACD,QAAM,EAAE,QAAQ,eAAe,iBAAiB,IAAI;AACpD,QAAM,iBAAiB,CAAC,QAAgB;AA3C1C;AA4CI,QAAI,KAAK,gBAAgB;AACvB,aAAO,KAAK,eAAe,GAAG;AAAA,IAChC;AAEA,QAAI,KAAK,OAAO,YAAY,GAAG;AAC7B,YAAM,OAAO;AAAA,UACV,UAAK,OAAO,YAAY,MAAxB,YAA6B,MAAM;AAAA,MACtC;AACA,aAAO,KAAK;AAAA,IACd;AAIA,QAAI,CAAC,KAAK,2BAA2B;AACnC,aAAO;AAAA,IACT;AAEA,WAAO,KAAK,OAAO;AAAA,EACrB;AACA,QAAM,YAAoC,CAAC;AAC3C,SAAO,QAAQ,CAAC,UAAU;AAhE5B;AAiEI,UAAM,MAAM,YAAY,KAAK;AAC7B,UAAM,WAAW,+CAAgB;AACjC,QAAI,UAAU;AACZ,gBAAU,GAAG,IAAI;AACjB;AAAA,IACF;AACA,UAAM,YAAY,MAAM,OAAO;AAC/B,QAAI,cAAc;AAClB,QAAI,MAAM,SAAS,cAAc;AAS/B,UAAI,KAAK,kBAAkB;AACzB,cAAM,OAAO,KAAK,OAAO,YAAY;AACrC,cAAM,UAAoB,CAAC;AAC3B,cAAM,gBAAe,UAAK,cAAL,YAAkB;AACvC,YAAI,kBAAkB;AACtB,iBAAS,IAAI,GAAG,IAAI,WAAW,KAAK;AAClC,gBAAM,QAAQ,MAAM,OAAO,CAAC;AAC5B,gBAAM,aAAa,KAAK;AAAA,YACtB,KAAK,MAAM,MAAM,OAAO,YAAY;AAAA,YACpC;AAAA,UACF;AACA,mBAAS,IAAI,GAAG,IAAI,YAAY,KAAK;AACnC,oBAAQ,KAAK,MAAM,EAAE;AAAA,UACvB;AACA,6BAAmB;AAAA,QACrB;AACA,YAAI,QAAQ,SAAS,GAAG;AAGtB,gBAAM,cAAc,wBAAwB,MAAM,EAAE;AACpD,mBAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACvC,kBAAM,IAAI,KAAK,MAAM,YAAY,KAAK,IAAI,EAAE;AAC5C,aAAC,QAAQ,CAAC,GAAG,QAAQ,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,QAAQ,CAAC,CAAC;AAAA,UACpD;AAEA,gBAAM,WAAW,EAAE,sBAAQ,OAAO,QAAQ;AAC1C,wBAAc,MAAM,OAAO,KAAK,CAAC,MAAM,EAAE,OAAO,QAAQ,QAAQ,CAAC;AAAA,QACnE,OAAO;AACL,wBAAc,MAAM,OAAO,YAAY,CAAC;AAAA,QAC1C;AAAA,MACF,OAAO;AACL,YAAI,IAAI,eAAe,MAAM,EAAE;AAC/B,sBAAc,MAAM,OAAO,YAAY,CAAC;AACxC,iBAAS,IAAI,GAAG,IAAI,WAAW,KAAK;AAClC,cAAI,IAAI,MAAM,OAAO,CAAC,EAAE,QAAQ,GAAG;AACjC,0BAAc,MAAM,OAAO,CAAC;AAC5B;AAAA,UACF;AACA,eAAK,MAAM,OAAO,CAAC,EAAE;AAAA,QACvB;AAAA,MACF;AAAA,IACF,WAAW,MAAM,SAAS,WAAW;AACnC,eAAS,IAAI,GAAG,IAAI,WAAW,KAAK;AAClC,YACE,UAAU,MAAM,MAAM,OAAO,CAAC,EAAE,MAAM;AAAA,UACpC,OAAM,oBAAI,KAAK,GAAE,YAAY;AAAA,WAC1B,yBACA,wBAAwB,IACxB,KAAK,OACT,GACD;AACA,wBAAc,MAAM,OAAO,CAAC;AAAA,QAC9B;AAAA,MACF;AAAA,IACF;AAEA,QAAI,aAAa;AACf,gBAAU,GAAG,IAAI,YAAY;AAC7B,UAAI,MAAM,cAAc,YAAY,YAAY;AAC9C,kBAAU,OAAO,MAAM,YAAY,IAAI,YAAY;AAAA,MACrD;AACA,UAAI,MAAM,SAAS,cAAc;AAC/B,6DAAmB,KAAK,YAAY;AAAA,MACtC;AAAA,IACF;AAAA,EACF,CAAC;AAED,SAAO;AACT;AAOO,SAAS,eACd,QACA,WACA,SACA;AACA,QAAM,oBAA4C,CAAC;AAEnD,WAAS,mBAAmB,OAAc;AACxC,QAAI,CAAC,SAAS;AACZ,aAAO;AAAA,IACT;AACA,QAAI,QAAQ,cAAc,CAAC,QAAQ,WAAW,SAAS,MAAM,SAAS,GAAG;AACvE,aAAO;AAAA,IACT;AACA,QAAI,QAAQ,gBAAgB,CAAC,QAAQ,aAAa,KAAK,GAAG;AACxD,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AAEA,SAAO,KAAK,SAAS,EAAE,QAAQ,CAAC,iBAAiB;AAC/C,UAAM,CAAC,EAAE,OAAO,IAAI,aAAa,MAAM,GAAG;AAC1C,UAAM,UAAU,UAAU,YAAY;AACtC,UAAM,QAAQ,OAAO;AAAA,MACnB,CAAC,MAAM,EAAE,OAAO,WAAW,EAAE,eAAe;AAAA,IAC9C;AACA,QAAI,SAAS,MAAM,cAAc,mBAAmB,KAAK,GAAG;AAC1D,YAAM,QACJ,MAAM,OACN,KAAK,CAAC,MAAM,EAAE,OAAO,WAAW,EAAE,eAAe,OAAO;AAC1D,UAAI,+BAAO,YAAY;AAErB,0BAAkB,GAAG,MAAM,YAAY,IAAI,MAAM;AAAA,MACnD;AAAA,IACF;AAAA,EACF,CAAC;AACD,SAAO;AACT;AAYO,SAAS,wBACd,QACA,KACA,OAC4B;AAC5B,QAAM,CAAC,EAAE,OAAO,IAAI,IAAI,MAAM,GAAG;AACjC,QAAM,QAAQ,OAAO;AAAA,IACnB,CAAC,MAAM,EAAE,OAAO,WAAW,EAAE,eAAe;AAAA,EAC9C;AAEA,MAAI,CAAC,OAAO;AACV,UAAM,IAAI,MAAM,4BAA4B,MAAM;AAAA,EACpD;AAEA,QAAM,aAAa,MAAM,OAAO;AAAA,IAC9B,CAAC,MAAM,EAAE,OAAO,SAAS,EAAE,eAAe;AAAA,EAC5C;AAEA,MAAI,eAAe,IAAI;AACrB,UAAM,IAAI,MAAM,wBAAwB,mBAAmB,MAAM;AAAA,EACnE;AAEA,SAAO;AAAA,IACL,MAAM,MAAM;AAAA,IACZ,aAAa,MAAM;AAAA,IACnB,YAAY,MAAM;AAAA,IAClB,MAAM,eAAe,IAAI,aAAa;AAAA,IACtC,aAAa;AAAA,IACb,iBAAiB,MAAM;AAAA,IACvB,iBACE,cAAc,KAAK,MAAM,OAAO,UAAU,EAAE,aACxC,MAAM,OAAO,UAAU,EAAE,aACzB;AAAA,EACR;AACF;AAKO,SAAS,kBACd,QACA,WAC4C;AAC5C,SAAO,OAAO;AAAA,IACZ,OAAO,QAAQ,SAAS,EAAE,IAAI,CAAC,CAAC,KAAK,KAAK,MAAM;AAC9C,aAAO,CAAC,KAAK,wBAAwB,QAAQ,KAAK,KAAK,CAAC;AAAA,IAC1D,CAAC;AAAA,EACH;AACF;",
  "names": []
}
