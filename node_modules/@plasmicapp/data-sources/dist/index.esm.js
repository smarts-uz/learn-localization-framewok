var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.tsx
import { usePlasmicDataConfig as usePlasmicDataConfig2 } from "@plasmicapp/query";

// src/components/Fetcher.tsx
import React2 from "react";

// src/hooks/usePlasmicDataOp.tsx
import { usePlasmicDataSourceContext } from "@plasmicapp/data-sources-context";
import * as ph from "@plasmicapp/host";
import {
  useMutablePlasmicQueryData,
  usePlasmicDataConfig
} from "@plasmicapp/query";
import * as React from "react";

// src/executor.tsx
import fetch from "@plasmicapp/isomorphic-unfetch";
import { wrapLoadingFetcher } from "@plasmicapp/query";
import stringify from "fast-stringify";

// src/placeholders.ts
var PLASMIC_UNDEFINED = "__PLASMIC_UNDEFINED";
function addPlaceholders(val) {
  return val === void 0 ? PLASMIC_UNDEFINED : val;
}
function addPlaceholdersToUserArgs(userArgs) {
  if (!userArgs) {
    return userArgs;
  }
  Object.entries(userArgs).forEach(([key, val]) => {
    userArgs[key] = Array.isArray(val) ? val.map((v) => addPlaceholders(v)) : addPlaceholders(val);
  });
  return userArgs;
}

// src/executor.tsx
var DEFAULT_HOST = "https://data.plasmic.app";
var UNAUTHORIZED_MESSAGE = "You do not have permission to perform this operation. Login to get access or contact the app owner to get access.";
function executePlasmicDataOp(op, opts) {
  return __async(this, null, function* () {
    const func = getConfig(
      "__PLASMIC_EXECUTE_DATA_OP",
      _executePlasmicDataOp
    );
    op.userArgs = addPlaceholdersToUserArgs(op.userArgs);
    const res = yield wrapLoadingFetcher(func)(op, opts);
    return res;
  });
}
function _executePlasmicDataOp(op, opts) {
  return __async(this, null, function* () {
    var _a;
    if (op.roleId) {
      if (!(opts == null ? void 0 : opts.user) || !opts.user.roleIds.includes(op.roleId)) {
        console.error(UNAUTHORIZED_MESSAGE);
        throw new Error(UNAUTHORIZED_MESSAGE);
      }
    }
    const host = getConfig("__PLASMIC_DATA_HOST", DEFAULT_HOST);
    const url = `${host}/api/v1/server-data/sources/${op.sourceId}/execute`;
    const resp = yield fetch(url, {
      method: "POST",
      headers: __spreadValues({
        "Content-Type": "application/json"
      }, (opts == null ? void 0 : opts.userAuthToken) && {
        "x-plasmic-data-user-auth-token": opts.userAuthToken
      }),
      body: stringify({
        opId: op.opId,
        userArgs: (_a = op.userArgs) != null ? _a : {},
        paginate: opts == null ? void 0 : opts.paginate
      })
    });
    if (resp.status !== 200) {
      const text = yield resp.text();
      throw new Error(text);
    }
    return yield resp.json();
  });
}
function getConfig(key, defaultValue) {
  var _a;
  if (typeof globalThis === "undefined") {
    return defaultValue;
  } else {
    return (_a = globalThis[key]) != null ? _a : defaultValue;
  }
}

// src/utils.ts
function swallow(f) {
  try {
    return f();
  } catch (e) {
    return void 0;
  }
}
function pick(obj, ...keys) {
  const res = {};
  for (const key of keys) {
    if (key in obj) {
      res[key] = obj[key];
    }
  }
  return res;
}
var tuple = (...args) => args;
function mkIdMap(xs) {
  return new Map(xs.map((x) => tuple(x.id, x)));
}
function withoutNils(xs) {
  return xs.filter((x) => x != null);
}

// src/hooks/usePlasmicDataOp.tsx
var isRSC2 = React.isRSC;
function makeCacheKey(dataOp, opts) {
  const queryDependencies = JSON.stringify({
    sourceId: dataOp.sourceId,
    opId: dataOp.opId,
    args: dataOp.userArgs,
    userAuthToken: opts == null ? void 0 : opts.userAuthToken,
    paginate: opts == null ? void 0 : opts.paginate
  });
  return dataOp.cacheKey ? `${dataOp.cacheKey}${queryDependencies}` : queryDependencies;
}
function usePlasmicInvalidate() {
  const { cache, fallback, mutate } = usePlasmicDataConfig();
  return (invalidatedKeys) => __async(this, null, function* () {
    const getKeysToInvalidate = () => {
      var _a, _b;
      if (!invalidatedKeys) {
        return [];
      }
      const allKeys = Array.from(
        /* @__PURE__ */ new Set([
          ...Array.from(cache.keys()),
          ...fallback ? Object.keys(fallback) : [],
          // If this is running within the Studio, we also take the
          // opportunity to invalidate the Studio cache. The keys that
          // Studio may have can be a superset of `cache` here, because
          // `cache` is updated as swr hooks are mounted and unmounted,
          // but Studio's data cache keys don't get removed when hooks
          // are unmounted. This makes it possible for Studio to hold
          // onto a stale cache entry that doesn't get invalidated.
          // For example, Studio may render page1, with key X, then goes
          // to page 2, which performs a mutate. At this point, Studio
          // has a cache entry for key X, but `cache` does not, because
          // page2 does not use that query. But page 2 may perform a
          // mutation that invalidates X. So we need to invalidate not
          // only keys in `cache`, but also keys that Studio is still
          // holding onto.
          ...(_b = (_a = globalThis.__PLASMIC_GET_ALL_CACHE_KEYS) == null ? void 0 : _a.call(globalThis)) != null ? _b : []
        ])
      ).filter((key) => typeof key === "string");
      if (invalidatedKeys.includes("plasmic_refresh_all")) {
        return allKeys;
      }
      return allKeys.filter(
        (key) => invalidatedKeys.some((k) => key.includes(`.$.${k}.$.`))
      );
    };
    const keys = getKeysToInvalidate();
    if (keys.length === 0) {
      return;
    }
    const invalidateKey = (key) => __async(this, null, function* () {
      const studioInvalidate = globalThis.__PLASMIC_MUTATE_DATA_OP;
      if (studioInvalidate) {
        yield studioInvalidate(key);
      }
      return mutate(key);
    });
    return yield Promise.all(keys.map((key) => invalidateKey(key)));
  });
}
var enableLoadingBoundaryKey = "plasmicInternalEnableLoadingBoundary";
function mkUndefinedDataProxy(promiseRef, fetchAndUpdateCache) {
  let fetchAndUpdatePromise = void 0;
  return new Proxy(
    {},
    {
      get: (_target, prop) => {
        if (prop === "isPlasmicUndefinedDataProxy") {
          return true;
        }
        if (!fetchAndUpdateCache) {
          return void 0;
        }
        const doFetchAndUpdate = () => {
          if (!fetchAndUpdatePromise) {
            fetchAndUpdatePromise = fetchAndUpdateCache().finally(() => {
              fetchAndUpdatePromise = void 0;
            });
          }
          return fetchAndUpdatePromise;
        };
        const promise = (
          // existing fetch
          promiseRef.fetchingPromise || // No existing fetch, so kick off a fetch
          doFetchAndUpdate()
        );
        promise.plasmicType = "PlasmicUndefinedDataError";
        promise.message = `Cannot read property ${String(
          prop
        )} - data is still loading`;
        throw promise;
      }
    }
  );
}
function isPlasmicUndefinedDataErrorPromise(x) {
  return !!x && typeof x === "object" && x.plasmicType === "PlasmicUndefinedDataError";
}
var reactMajorVersion = +React.version.split(".")[0];
function resolveDataOp(dataOp) {
  if (typeof dataOp === "function") {
    try {
      return dataOp();
    } catch (err) {
      if (isPlasmicUndefinedDataErrorPromise(err)) {
        return err;
      }
      return null;
    }
  } else {
    return dataOp;
  }
}
var PRE_FETCHES = /* @__PURE__ */ new Map();
function usePlasmicDataOp(dataOp, opts) {
  var _a, _b;
  const resolvedDataOp = resolveDataOp(dataOp);
  const ctx = usePlasmicDataSourceContext();
  const enableLoadingBoundary = !!((_b = (_a = ph.useDataEnv) == null ? void 0 : _a()) == null ? void 0 : _b[enableLoadingBoundaryKey]);
  const { mutate, cache } = isRSC2 ? {} : usePlasmicDataConfig();
  const isNullDataOp = !resolvedDataOp;
  const isWaitingOnDependentQuery = isPlasmicUndefinedDataErrorPromise(resolvedDataOp);
  const key = !resolvedDataOp || isPlasmicUndefinedDataErrorPromise(resolvedDataOp) ? null : makeCacheKey(resolvedDataOp, {
    paginate: opts == null ? void 0 : opts.paginate,
    userAuthToken: ctx == null ? void 0 : ctx.userAuthToken
  });
  const fetchingData = React.useMemo(
    () => ({
      fetchingPromise: void 0
    }),
    [key]
  );
  const fetcher = React.useMemo(
    () => () => {
      if (!key) {
        throw new Error(`Fetcher should never be called without a proper key`);
      }
      if (fetchingData.fetchingPromise) {
        return fetchingData.fetchingPromise;
      }
      if (key && PRE_FETCHES.has(key)) {
        const existing = PRE_FETCHES.get(key);
        fetchingData.fetchingPromise = existing;
        return existing;
      }
      const fetcherFn = () => executePlasmicDataOp(resolvedDataOp, {
        userAuthToken: (ctx == null ? void 0 : ctx.userAuthToken) || void 0,
        user: ctx == null ? void 0 : ctx.user,
        paginate: opts == null ? void 0 : opts.paginate
      });
      const fetcherPromise = fetcherFn();
      fetchingData.fetchingPromise = fetcherPromise;
      if (key) {
        PRE_FETCHES.set(key, fetcherPromise);
        fetcherPromise.then(
          () => {
            PRE_FETCHES.delete(key);
          },
          () => {
            PRE_FETCHES.delete(key);
          }
        );
      }
      return fetcherPromise;
    },
    [key, fetchingData]
  );
  const dependentKeyDataErrorPromise = isPlasmicUndefinedDataErrorPromise(
    resolvedDataOp
  ) ? resolvedDataOp : void 0;
  const fetchAndUpdateCache = React.useMemo(() => {
    if (!key && !dependentKeyDataErrorPromise) {
      return void 0;
    }
    return () => {
      if (fetchingData.fetchingPromise) {
        return fetchingData.fetchingPromise;
      }
      if (dependentKeyDataErrorPromise) {
        return dependentKeyDataErrorPromise;
      }
      if (!key) {
        throw new Error(`Expected key to be non-null`);
      }
      const cached = cache == null ? void 0 : cache.get(key);
      if (cached) {
        return Promise.resolve(cached);
      }
      const cachedError = cache == null ? void 0 : cache.get(`$swr$${key}`);
      if (cachedError) {
        return Promise.reject(cachedError.error);
      }
      const fetcherPromise = new Promise((resolve, reject) => {
        setTimeout(() => {
          fetcher().then(resolve, reject);
        }, 1);
      });
      if (!isRSC2)
        fetcherPromise.then((data2) => {
          mutate == null ? void 0 : mutate(key, data2);
        }).catch((err) => {
          var _a2;
          const keyInfo = key ? "$swr$" + key : "";
          cache == null ? void 0 : cache.set(keyInfo, __spreadProps(__spreadValues({}, (_a2 = cache == null ? void 0 : cache.get(keyInfo)) != null ? _a2 : {}), { error: err }));
        });
      return fetcherPromise;
    };
  }, [fetcher, fetchingData, cache, key, dependentKeyDataErrorPromise]);
  const res = useMutablePlasmicQueryData(key, fetcher, {
    shouldRetryOnError: false,
    // If revalidateIfStale is true, then if there's a cache entry with a key,
    // but no mounted hook with that key yet, and when the hook mounts with the key,
    // swr will revalidate. This may be reasonable behavior, but for us, this
    // happens all the time -- we prepopulate the cache with proxy-invoked fetch,
    // sometimes before swr had a chance to run the effect.  So we turn off
    // revalidateIfStale here, and just let the user manage invalidation.
    revalidateIfStale: false
  });
  const { data, error, isLoading } = res;
  if (fetchingData.fetchingPromise != null && data !== void 0) {
    fetchingData.fetchingPromise = void 0;
  }
  return React.useMemo(() => {
    const result = __spreadValues(__spreadValues({}, data != null ? data : {}), pick(res, "isLoading", "error"));
    if (!(opts == null ? void 0 : opts.noUndefinedDataProxy) && reactMajorVersion >= 18 && enableLoadingBoundary && (isLoading || isNullDataOp || isWaitingOnDependentQuery) && result.data === void 0 && result.schema === void 0 && result.error === void 0) {
      result.data = mkUndefinedDataProxy(fetchingData, fetchAndUpdateCache);
      result.schema = mkUndefinedDataProxy(fetchingData, fetchAndUpdateCache);
    }
    return result;
  }, [
    isNullDataOp,
    isWaitingOnDependentQuery,
    data,
    error,
    isLoading,
    opts == null ? void 0 : opts.noUndefinedDataProxy,
    enableLoadingBoundary,
    fetchingData,
    fetchAndUpdateCache
  ]);
}
function usePlasmicDataMutationOp(dataOp) {
  const ctx = usePlasmicDataSourceContext();
  const userToken = ctx == null ? void 0 : ctx.userAuthToken;
  const getRealDataOp = React.useCallback(() => __async(this, null, function* () {
    const tryGetRealDataOp = () => __async(this, null, function* () {
      const resolved = resolveDataOp(dataOp);
      if (!resolved) {
        return null;
      } else if (isPlasmicUndefinedDataErrorPromise(resolved)) {
        yield resolved;
        return tryGetRealDataOp();
      } else {
        return resolved;
      }
    });
    return yield tryGetRealDataOp();
  }), [dataOp]);
  return React.useCallback(() => __async(this, null, function* () {
    var _a;
    const { sourceId, opId, userArgs } = (_a = yield getRealDataOp()) != null ? _a : {};
    if (!sourceId || !opId) {
      return void 0;
    }
    return executePlasmicDataOp(
      { sourceId, opId, userArgs },
      {
        userAuthToken: userToken || void 0,
        user: ctx == null ? void 0 : ctx.user
      }
    );
  }), [getRealDataOp, userToken]);
}

// src/components/Fetcher.tsx
function Fetcher(props) {
  var _a;
  const { dataOp, children, name, pageIndex, pageSize } = props;
  const data = usePlasmicDataOp(dataOp, __spreadValues({}, !!pageIndex && !!pageSize && {
    paginate: { pageIndex, pageSize }
  }));
  const $queries = React2.useMemo(
    () => __spreadProps(__spreadValues({}, props.queries), { [name != null ? name : "data"]: data }),
    [props.queries, name, data]
  );
  return (_a = children == null ? void 0 : children($queries)) != null ? _a : null;
}
var FetcherMeta = {
  name: "plasmic-data-source-fetcher",
  displayName: "Data Fetcher",
  props: {
    dataOp: {
      type: "dataSourceOp",
      displayName: "Data"
    },
    name: {
      type: "string",
      displayName: "Variable name"
    },
    children: {
      type: "slot",
      renderPropParams: ["$queries"]
    },
    pageSize: {
      type: "number",
      advanced: true,
      displayName: "Page size",
      description: "Only fetch in batches of this size; for pagination"
    },
    pageIndex: {
      type: "number",
      advanced: true,
      displayName: "Page index",
      description: "0-based index of the paginated page to fetch"
    }
  },
  importPath: "@plasmicapp/react-web/lib/data-sources",
  importName: "Fetcher",
  alwaysAutoName: true,
  styleSections: false
};

// src/helpers.ts
import { useMemo as useMemo2 } from "react";
function normalizeData(rawData) {
  var _a;
  if (!rawData) {
    return void 0;
  }
  const dataArray = tryGetDataArray(rawData);
  if (!dataArray) {
    return void 0;
  }
  const schema = (_a = rawData.schema) != null ? _a : tryGetSchema(dataArray);
  if (!schema) {
    return void 0;
  }
  return { data: dataArray, schema };
}
function useNormalizedData(rawData) {
  return useMemo2(() => normalizeData(rawData), [rawData]);
}
function tryGetDataArray(rawData) {
  if (rawData == null || typeof rawData !== "object") {
    return void 0;
  }
  if (Array.isArray(rawData)) {
    if (isArrayOfObjects(rawData)) {
      return rawData;
    } else {
      return void 0;
    }
  }
  if (rawData == null) {
    return void 0;
  }
  if ("data" in rawData && typeof rawData.data === "object") {
    if (Array.isArray(rawData.data) && isArrayOfObjects(rawData.data)) {
      return rawData.data;
    } else if (rawData.data != null) {
      return [rawData.data];
    } else {
      return void 0;
    }
  }
  if ("isLoading" in rawData || "error" in rawData) {
    return void 0;
  }
  return [rawData];
}
function isArrayOfObjects(arr) {
  return arr.every((x) => typeof x === "object" && !Array.isArray(x));
}
function tryGetSchema(data) {
  const fieldMap = {};
  data.forEach((entry) => {
    if (entry && typeof entry === "object") {
      Array.from(Object.entries(entry)).forEach(([k, v]) => {
        const inferredType = typeof v === "string" ? "string" : typeof v === "boolean" ? "boolean" : typeof v === "number" ? "number" : "unknown";
        if (fieldMap[k] && fieldMap[k] !== inferredType) {
          fieldMap[k] = "unknown";
        } else {
          fieldMap[k] = inferredType;
        }
      });
    }
  });
  return {
    id: "inferred",
    fields: Object.entries(fieldMap).map(([f, t]) => ({
      id: f,
      type: t,
      readOnly: false
    }))
  };
}
var mkShortId = () => `${Math.random()}`;
function deriveFieldConfigs(specifiedFieldsPartial, schema, makeDefaultConfig) {
  var _a;
  const schemaFields = (_a = schema == null ? void 0 : schema.fields) != null ? _a : [];
  const fieldById = mkIdMap(schemaFields);
  const specifiedFieldIds = new Set(
    withoutNils(specifiedFieldsPartial.map((f) => f.fieldId))
  );
  const keptSpecifiedFields = specifiedFieldsPartial.flatMap((f) => {
    if (!f.fieldId) {
      return [
        __spreadValues(__spreadValues({ key: mkShortId() }, makeDefaultConfig(void 0)), f)
      ];
    }
    const field = fieldById.get(f.fieldId);
    if (!field) {
      return [];
    }
    return [
      __spreadValues(__spreadValues({
        key: mkShortId()
      }, makeDefaultConfig(field)), f)
    ];
  });
  const newVirtualFields = schemaFields.filter((f) => !specifiedFieldIds.has(f.id)).map(
    (f) => __spreadValues({
      key: mkShortId()
    }, makeDefaultConfig(f))
  );
  const mergedFields = [...keptSpecifiedFields, ...newVirtualFields];
  const minimalFullLengthFields = [
    ...specifiedFieldsPartial,
    ...newVirtualFields.map((f) => ({ key: f.key, fieldId: f.fieldId }))
  ];
  return { mergedFields, minimalFullLengthFields };
}

// src/hooks/useDependencyAwareQuery.tsx
import React3 from "react";
function usePrevious(value) {
  const prevValue = React3.useRef(void 0);
  React3.useEffect(() => {
    prevValue.current = value;
    return () => {
      prevValue.current = void 0;
    };
  });
  return prevValue.current;
}
function useDependencyAwareQuery({
  $queries,
  getDataOp,
  setDollarQueries,
  name,
  pageIndex,
  pageSize
}) {
  const data = usePlasmicDataOp(swallow(getDataOp), __spreadValues({}, !!pageIndex && !!pageSize && {
    paginate: { pageIndex, pageSize }
  }));
  const finalName = name != null ? name : "data";
  const prevName = usePrevious(finalName);
  React3.useEffect(() => {
    if (!(finalName in $queries) || $queries[finalName] !== data) {
      const $queries2 = __spreadProps(__spreadValues({}, $queries), {
        [finalName]: data
      });
      if (prevName && finalName !== prevName && prevName in $queries) {
        delete $queries2[prevName];
      }
      setDollarQueries($queries2);
    }
  }, [finalName, prevName, data, $queries, setDollarQueries]);
}
export {
  Fetcher,
  FetcherMeta,
  deriveFieldConfigs,
  executePlasmicDataOp,
  makeCacheKey,
  normalizeData,
  useDependencyAwareQuery,
  useNormalizedData,
  usePlasmicDataConfig2 as usePlasmicDataConfig,
  usePlasmicDataMutationOp,
  usePlasmicDataOp,
  usePlasmicInvalidate
};
//# sourceMappingURL=index.esm.js.map
