import { ComponentMeta } from '@plasmicapp/host';
import { PlasmicDataSourceContextValue } from '@plasmicapp/data-sources-context';
import { default as React_2 } from 'react';
import { usePlasmicDataConfig } from '@plasmicapp/query';

export declare type BaseFieldConfig = {
    key?: string;
    fieldId?: string;
};

export declare interface DataOp {
    sourceId: string;
    opId: string;
    userArgs?: Record<string, any>;
    cacheKey?: string;
    invalidatedKeys?: string[] | null;
    roleId?: string | null;
}

declare interface DataOpConfig {
    name?: string;
    pageIndex?: number;
    pageSize?: number;
}

export declare interface DataSourceSchema {
    tables: TableSchema[];
}

declare interface DependencyAwareQueryConfig extends DataOpConfig {
    $queries: Record<string, any>;
    setDollarQueries: ($queries: Record<string, any>) => void;
    getDataOp: () => DataOp;
}

export declare function deriveFieldConfigs<T extends BaseFieldConfig>(specifiedFieldsPartial: Partial<T>[], schema: TableSchema | undefined, makeDefaultConfig: (field: TableFieldSchema | undefined) => T): {
    mergedFields: T[];
    minimalFullLengthFields: Partial<T>[];
};

declare interface ExecuteOpts {
    userAuthToken?: string;
    user?: PlasmicDataSourceContextValue["user"];
    paginate?: Pagination;
}

export declare function executePlasmicDataOp<T extends SingleRowResult | ManyRowsResult>(op: DataOp, opts?: ExecuteOpts): Promise<T>;

export declare function Fetcher(props: FetcherProps): React_2.ReactElement | null;

export declare const FetcherMeta: ComponentMeta<FetcherProps>;

export declare interface FetcherProps extends DataOpConfig {
    dataOp?: DataOp;
    children?: ($queries: Record<string, any>) => React_2.ReactElement | null;
    queries?: Record<string, any>;
}

export declare function makeCacheKey(dataOp: DataOp, opts?: {
    paginate?: Pagination;
    userAuthToken?: string | null;
}): string;

export declare interface ManyRowsResult<T = any> {
    data: T[];
    total?: number;
    schema: TableSchema;
    paginate?: Pagination;
}

export declare function normalizeData(rawData: unknown): NormalizedData | undefined;

export declare interface NormalizedData {
    data: Record<string, unknown>[];
    schema?: TableSchema;
}

export declare interface Pagination {
    pageSize: number;
    pageIndex: number;
}

export declare type QueryResult = Partial<ManyRowsResult<any>> & {
    error?: any;
    isLoading?: boolean;
};

declare type ResolvableDataOp = DataOp | undefined | null | (() => DataOp | undefined | null);

export declare interface SingleRowResult<T = any> {
    data: T;
    schema: TableSchema;
}

export declare interface TableFieldSchema {
    id: string;
    label?: string;
    type: TableFieldType;
    readOnly: boolean;
    primaryKey?: boolean;
    options?: string[];
}

export declare type TableFieldType = "string" | "boolean" | "number" | "date" | "datetime" | "enum" | "json" | "unknown";

export declare interface TableSchema {
    id: string;
    schema?: string;
    label?: string;
    fields: TableFieldSchema[];
}

/**
 * @deprecated Prefer using `usePlasmicDataOp` directly instead.
 */
export declare function useDependencyAwareQuery({ $queries, getDataOp, setDollarQueries, name, pageIndex, pageSize, }: DependencyAwareQueryConfig): void;

export declare function useNormalizedData(rawData: unknown): NormalizedData | undefined;

export { usePlasmicDataConfig }

export declare function usePlasmicDataMutationOp<T extends SingleRowResult | ManyRowsResult>(dataOp: ResolvableDataOp): () => Promise<T | undefined>;

export declare function usePlasmicDataOp<T extends SingleRowResult | ManyRowsResult, E = any>(dataOp: ResolvableDataOp, opts?: {
    paginate?: Pagination;
    noUndefinedDataProxy?: boolean;
}): Partial<T> & {
    error?: E;
    isLoading?: boolean;
};

/**
 * Returns a function that can be used to invalidate Plasmic query groups.
 */
export declare function usePlasmicInvalidate(): (invalidatedKeys: string[] | null | undefined) => Promise<any[] | undefined>;

export { }
