{"version":3,"file":"plume-utils-9472dfe6.js","sources":["../../src/plume/plume-utils.ts"],"sourcesContent":["import * as React from \"react\";\nimport { groupBy, mapValues } from \"../common\";\nimport { SingleChoiceArg } from \"../render/elements\";\n\nexport let PLUME_STRICT_MODE = true;\n\nexport function setPlumeStrictMode(mode: boolean) {\n  PLUME_STRICT_MODE = mode;\n}\n\ntype VariantArgChoices<T> = T extends (infer M)[]\n  ? M\n  : T extends SingleChoiceArg<infer M>\n  ? M\n  : never;\ntype VariantArgsChoices<V> = { [k in keyof V]-?: VariantArgChoices<V[k]> };\ntype DictValues<V extends Record<string, any>> = V[keyof V];\ntype DictTuples<V extends Record<string, any>> = DictValues<\n  { [K in keyof V]: [K, V[K]] }\n>;\nexport type VariantDefTuple<V> = DictTuples<VariantArgsChoices<V>>;\n\ntype DistributeTuple<T> = T extends [infer T1, infer T2]\n  ? { group: T1; variant: T2 }\n  : never;\n\nexport type VariantDef<V> = DistributeTuple<VariantDefTuple<V>>;\n\nexport type PlasmicClass<\n  V extends Record<string, any>,\n  A extends Record<string, any>,\n  O extends Record<string, any>\n> = {\n  (props: { variants?: V; args?: A; overrides?: O }): React.ReactElement | null;\n  internalVariantProps: (keyof V)[];\n  internalArgProps: (keyof A)[];\n};\n\nexport type AnyPlasmicClass = PlasmicClass<any, any, any>;\n\nexport type PlasmicClassVariants<\n  C extends AnyPlasmicClass\n> = C extends PlasmicClass<infer V, any, any> ? V : unknown;\nexport type PlasmicClassArgs<\n  C extends AnyPlasmicClass\n> = C extends PlasmicClass<any, infer A, any> ? A : unknown;\nexport type PlasmicClassOverrides<\n  C extends AnyPlasmicClass\n> = C extends PlasmicClass<any, any, infer O> ? O : unknown;\n\ntype BooleanLike = boolean | undefined | null;\n\nexport function mergeVariantToggles<V>(\n  ...toggles: { def?: VariantDef<V>; active: BooleanLike }[]\n) {\n  const definedToggles = toggles.filter((x) => !!x.def) as {\n    def: VariantDef<V>;\n    active: BooleanLike;\n  }[];\n  const grouped = groupBy(definedToggles, ({ def }) => def.group as string);\n  return mapValues(grouped, (subToggles) => {\n    return Object.fromEntries(\n      subToggles.map(({ def, active }) => [def.variant, !!active])\n    );\n  });\n}\n\nexport function noOutline() {\n  return { outline: \"none\" };\n}\n\nexport function getPlumeType(child: React.ReactChild): string | undefined {\n  if (!React.isValidElement(child)) {\n    return undefined;\n  }\n  const childType = child.type as any;\n  return (childType.__plumeType || childType.getPlumeType?.(child.props)) as\n    | string\n    | undefined;\n}\n"],"names":[],"mappings":";;;AAIO,IAAI,iBAAiB,GAAG,KAAK;SAgDpB,mBAAmB,GAAA;IACjC,IAA0D,OAAA,GAAA,EAAA,CAAA;SAA1D,IAA0D,EAAA,GAAA,CAAA,EAA1D,EAA0D,GAAA,SAAA,CAAA,MAAA,EAA1D,EAA0D,EAAA,EAAA;QAA1D,OAA0D,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA,CAAA;;AAE1D,IAAA,IAAM,cAAc,GAAG,OAAO,CAAC,MAAM,CAAC,UAAC,CAAC,EAAA,EAAK,OAAA,CAAC,CAAC,CAAC,CAAC,GAAG,CAAP,EAAO,CAGjD,CAAC;AACJ,IAAA,IAAM,OAAO,GAAG,OAAO,CAAC,cAAc,EAAE,UAAC,EAAO,EAAA;AAAL,QAAA,IAAA,GAAG,GAAA,EAAA,CAAA,GAAA,CAAA;QAAO,OAAA,GAAG,CAAC,KAAe,CAAA;AAAnB,KAAmB,CAAC,CAAC;AAC1E,IAAA,OAAO,SAAS,CAAC,OAAO,EAAE,UAAC,UAAU,EAAA;QACnC,OAAO,MAAM,CAAC,WAAW,CACvB,UAAU,CAAC,GAAG,CAAC,UAAC,EAAe,EAAA;gBAAb,GAAG,GAAA,EAAA,CAAA,GAAA,EAAE,MAAM,GAAA,EAAA,CAAA,MAAA,CAAA;YAAO,OAAA,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC,MAAM,CAAC,CAAA;SAAA,CAAC,CAC7D,CAAC;AACJ,KAAC,CAAC,CAAC;AACL,CAAC;SAEe,SAAS,GAAA;AACvB,IAAA,OAAO,EAAE,OAAO,EAAE,MAAM,EAAE,CAAC;AAC7B,CAAC;AAEK,SAAU,YAAY,CAAC,KAAuB,EAAA;;AAClD,IAAA,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,KAAK,CAAC,EAAE;AAChC,QAAA,OAAO,SAAS,CAAC;AAClB,KAAA;AACD,IAAA,IAAM,SAAS,GAAG,KAAK,CAAC,IAAW,CAAC;AACpC,IAAA,QAAQ,SAAS,CAAC,WAAW,KAAI,MAAA,SAAS,CAAC,YAAY,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAA,IAAA,CAAA,SAAA,EAAG,KAAK,CAAC,KAAK,CAAC,CAAA,EAExD;AAChB;;;;"}