import { a as __assign, o as omit, p as pick, d as __spreadArray, e as __read } from './common-7e2bbe30.js';
import { PlasmicDataSourceContextProvider } from '@plasmicapp/data-sources-context';
import { usePlasmicLinkMaybe, DataProvider, PlasmicLinkProvider } from '@plasmicapp/host';
import { SSRProvider, useIsSSR as useIsSSR$1 } from '@react-aria/ssr';
import * as React from 'react';
import React__default from 'react';
import { PlasmicHeadContext } from './render/PlasmicHead/index.js';

var PlasmicLink = React__default.forwardRef(function PlasmicLink(props, ref) {
    var _a;
    // The usePlasmicLinkMaybe function may be undefined, if host is not up-to-date
    var Link = (_a = usePlasmicLinkMaybe === null || usePlasmicLinkMaybe === void 0 ? void 0 : usePlasmicLinkMaybe()) !== null && _a !== void 0 ? _a : PlasmicLinkInternal;
    if (Link === PlasmicLink || Link === PlasmicLinkInternal) {
        // Just in case, break the cycle
        return React__default.createElement(PlasmicLinkInternal, __assign({}, props, { ref: ref }));
    }
    else {
        // Don't pass component/platform props to non-PlasmicLinkInternal
        return React__default.createElement(Link, __assign({}, omit(props, "component", "platform"), { ref: ref }));
    }
});
var PlasmicLinkInternal = React__default.forwardRef(function PlasmicLinkInternal(props, ref) {
    var _a;
    // props.href is required for nextjs; if no props.href,
    // then we just render the default anchor element
    if (props.platform === "nextjs" && props.href) {
        var nextjsProps = [
            "href",
            "replace",
            "scroll",
            "shallow",
            "passHref",
            "prefetch",
            "locale",
        ];
        // If this is a fragment identifier link, then we set
        // scroll={false} so that smooth scrolling works
        var isFragment = (_a = props.href) === null || _a === void 0 ? void 0 : _a.startsWith("#");
        return React__default.createElement(props.component, __assign(__assign({ scroll: !isFragment }, pick.apply(void 0, __spreadArray([props], __read(nextjsProps), false))), { legacyBehavior: true }), React__default.createElement("a", __assign({}, omit.apply(void 0, __spreadArray([props, "component", "platform"], __read(nextjsProps), false)), { ref: ref })));
    }
    if (props.platform === "gatsby" && isInternalHref(props.href)) {
        return React__default.createElement(props.component, __assign(__assign({}, omit(props, "component", "platform", "href")), { to: props.href, ref: ref }));
    }
    return React__default.createElement("a", __assign({}, omit(props, "component", "platform"), { ref: ref }));
});
function isInternalHref(href) {
    return /^\/(?!\/)/.test(href);
}

var PlasmicTranslatorContext = React__default.createContext(undefined);
function isIterable(val) {
    return val != null && typeof val[Symbol.iterator] === "function";
}
function usePlasmicTranslator() {
    var _t = React__default.useContext(PlasmicTranslatorContext);
    var translator = _t
        ? typeof _t === "function"
            ? _t
            : _t.translator
        : undefined;
    return translator;
}
function genTranslatableString(elt, opts) {
    var components = {};
    var componentsCount = 0;
    var getText = function (node) {
        var _a;
        if (!node) {
            return "";
        }
        if (typeof node === "number" ||
            typeof node === "boolean" ||
            typeof node === "string") {
            return node.toString();
        }
        if (typeof node !== "object") {
            return "";
        }
        if (Array.isArray(node) || isIterable(node)) {
            return Array.from(node)
                .map(function (child) { return getText(child); })
                .filter(function (child) { return !!child; })
                .join("");
        }
        var nodeChildren = (hasKey(node, "props") &&
            hasKey(node.props, "children") &&
            node.props.children) ||
            (hasKey(node, "children") && node.children) ||
            [];
        var contents = "".concat(React__default.Children.toArray(nodeChildren)
            .map(function (child) { return getText(child); })
            .filter(function (child) { return !!child; })
            .join(""));
        if (React__default.isValidElement(node) && node.type === React__default.Fragment) {
            return contents;
        }
        var prefix = (_a = opts === null || opts === void 0 ? void 0 : opts.tagPrefix) !== null && _a !== void 0 ? _a : "";
        var componentId = "".concat(prefix).concat(componentsCount + 1);
        componentsCount++;
        components[componentId] = React__default.isValidElement(node)
            ? React__default.cloneElement(node, {
                key: componentId,
                children: undefined,
            })
            : node;
        return "<".concat(componentId, ">").concat(contents, "</").concat(componentId, ">");
    };
    var str = getText(elt);
    return {
        str: str,
        components: components,
        componentsCount: componentsCount,
    };
}
function Trans(_a) {
    var transKey = _a.transKey, children = _a.children;
    var _t = React__default.useContext(PlasmicTranslatorContext);
    var translator = _t
        ? typeof _t === "function"
            ? _t
            : _t.translator
        : undefined;
    if (!translator) {
        warnNoTranslationFunctionAtMostOnce();
        return children;
    }
    var _b = genTranslatableString(children, {
        tagPrefix: typeof _t === "object" ? _t.tagPrefix : undefined,
    }), str = _b.str, components = _b.components, componentsCount = _b.componentsCount;
    return translator(transKey !== null && transKey !== void 0 ? transKey : str, componentsCount > 0 ? { components: components } : undefined);
}
var hasWarned = false;
function warnNoTranslationFunctionAtMostOnce() {
    if (!hasWarned) {
        console.warn("Using Plasmic Translation but no translation function has been provided");
        hasWarned = true;
    }
}
function hasKey(v, key) {
    return typeof v === "object" && v !== null && key in v;
}

var PlasmicRootContext = React.createContext(undefined);
function PlasmicRootProvider(props) {
    var _a, _b;
    var platform = props.platform, children = props.children, userAuthToken = props.userAuthToken, isUserLoading = props.isUserLoading, authRedirectUri = props.authRedirectUri, user = props.user, disableLoadingBoundary = props.disableLoadingBoundary, suspenseFallback = props.suspenseFallback;
    var context = React.useMemo(function () { return ({
        platform: platform,
    }); }, [platform]);
    var dataSourceContextValue = React.useMemo(function () { return ({
        userAuthToken: userAuthToken,
        user: user,
        isUserLoading: isUserLoading,
        authRedirectUri: authRedirectUri,
    }); }, [userAuthToken, isUserLoading, user, authRedirectUri]);
    var reactMajorVersion = +React.version.split(".")[0];
    return (React.createElement(MaybeWrap, { cond: !disableLoadingBoundary && reactMajorVersion >= 18, wrapper: function (children) { return (React.createElement(DataProvider, { name: "plasmicInternalEnableLoadingBoundary", hidden: true, data: true },
            React.createElement(React.Suspense, { fallback: suspenseFallback !== null && suspenseFallback !== void 0 ? suspenseFallback : "Loading..." }, children))); } },
        React.createElement(PlasmicRootContext.Provider, { value: context },
            React.createElement(SSRProvider, null,
                React.createElement(PlasmicDataSourceContextProvider, { value: dataSourceContextValue },
                    React.createElement(PlasmicTranslatorContext.Provider, { value: (_a = props.i18n) !== null && _a !== void 0 ? _a : props.translator },
                        React.createElement(PlasmicHeadContext.Provider, { value: props.Head },
                            React.createElement(SafePlasmicLinkProvider, { Link: (_b = props.Link) !== null && _b !== void 0 ? _b : PlasmicLinkInternal }, children))))))));
}
/**
 * A PlasmicLinkProvider that anticipates PlasmicLinkProvider may not exist yet from
 * @plasmicapp/host if the user is using an older version
 */
function SafePlasmicLinkProvider(props) {
    if (PlasmicLinkProvider) {
        return React.createElement(PlasmicLinkProvider, __assign({}, props));
    }
    else {
        return React.createElement(React.Fragment, null, props.children);
    }
}
var useIsSSR = useIsSSR$1;
function useHasPlasmicRoot() {
    return !!React.useContext(PlasmicRootContext);
}
var hasWarnedSSR = false;
/**
 * Warns the user if PlasmicRootProvider is not used
 */
function useEnsureSSRProvider() {
    var hasRoot = useHasPlasmicRoot();
    if (hasRoot || hasWarnedSSR || process.env.NODE_ENV !== "development") {
        return;
    }
    hasWarnedSSR = true;
    console.warn("Plasmic: To ensure your components work correctly with server-side rendering, please use PlasmicRootProvider at the root of your application.  See https://docs.plasmic.app/learn/ssr");
}
function MaybeWrap(props) {
    return props.cond ? props.wrapper(props.children) : props.children;
}

export { PlasmicLink as P, Trans as T, PlasmicRootProvider as a, usePlasmicTranslator as b, useEnsureSSRProvider as c, genTranslatableString as g, useIsSSR as u };
//# sourceMappingURL=ssr-f37a883d.js.map
