"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  usePlasmicAuth: () => usePlasmicAuth
});
module.exports = __toCommonJS(src_exports);
__reExport(src_exports, require("@plasmicapp/auth-api"), module.exports);

// src/hooks.ts
var import_auth_api = require("@plasmicapp/auth-api");
var import_query = require("@plasmicapp/query");
var storageUserKey = (appId) => `$user.${appId}`;
var isBrowser = typeof window !== "undefined";
function getCallbackParams() {
  const params = new URLSearchParams(window.location.search);
  const error = params.get("error");
  const code = params.get("code");
  const state = params.get("state");
  return {
    isCallbackError: !!error,
    isCodeExchange: !!code && !!state,
    error,
    code,
    state
  };
}
function getCodeVerifier() {
  try {
    return localStorage.getItem("code_verifier");
  } catch (err) {
    return null;
  }
}
function removeCallbackParams() {
  try {
    window.history.replaceState({}, "", location.pathname);
  } catch (err) {
    console.error(`Error while removing callback params: ${err}`);
  }
}
function isContinueToSameLocation(continueTo) {
  const pathname = window.location.pathname;
  const origin = window.location.origin;
  return continueTo === pathname || continueTo === origin + pathname;
}
function handleCallback(opts) {
  return __async(this, null, function* () {
    const { host, appId, code, state, codeVerifier } = opts;
    let continueTo = "/";
    try {
      if (state) {
        const parsedState = JSON.parse(state);
        continueTo = parsedState.continueTo;
      }
    } catch (err) {
      console.error(`Error while parsing state: ${err}`);
    }
    const result = yield (0, import_auth_api.getPlasmicAppUser)({
      host,
      appId,
      code,
      codeVerifier
    });
    if (result.error) {
      console.log(`Error while performing code exchange: ${result.error}`);
      return void 0;
    }
    localStorage.setItem(storageUserKey(appId), result.token);
    if (!isContinueToSameLocation(continueTo)) {
      window.location.assign(continueTo);
    } else {
      removeCallbackParams();
    }
    return { token: result.token, user: result.user };
  });
}
function checkAlreadyLoggedUser(opts) {
  return __async(this, null, function* () {
    const { appId, host } = opts;
    const token = localStorage.getItem(storageUserKey(appId));
    if (!token) {
      return { user: null, token: null };
    }
    const { user, error } = yield (0, import_auth_api.getPlasmicAppUserFromToken)({
      host,
      token
    });
    if (error) {
      localStorage.removeItem(storageUserKey(appId));
      console.log(`Error while checking logged user`);
      return { user: null, token: null };
    }
    return { user, token };
  });
}
function usePlasmicAuth(opts) {
  const { host, appId } = opts;
  const authKey = `$csq$plasmic-auth-${appId}`;
  const { data: userData, isLoading } = (0, import_query.useMutablePlasmicQueryData)(
    authKey,
    () => __async(this, null, function* () {
      if (!appId || !isBrowser) {
        return { user: null, token: null };
      }
      try {
        const callbackParams = getCallbackParams();
        if (callbackParams.isCallbackError || callbackParams.isCodeExchange) {
          if (callbackParams.isCallbackError) {
            removeCallbackParams();
            console.error(`Error: ${callbackParams.error}`);
            return { user: null, token: null };
          } else {
            const codeVerifier = getCodeVerifier();
            if (!codeVerifier) {
              removeCallbackParams();
              console.error("No code verifier found");
              return { user: null, token: null };
            } else {
              const result = yield handleCallback({
                host,
                appId,
                code: callbackParams.code,
                state: callbackParams.state,
                codeVerifier
              });
              if (!result) {
                removeCallbackParams();
                return { user: null, token: null };
              }
              return result;
            }
          }
        } else {
          return yield checkAlreadyLoggedUser({
            appId,
            host
          });
        }
      } catch (err) {
        console.error(`Error while handling auth: ${err}`);
      }
      return { user: null, token: null };
    })
  );
  return {
    user: userData == null ? void 0 : userData.user,
    token: userData == null ? void 0 : userData.token,
    isUserLoading: isLoading
  };
}
//# sourceMappingURL=index.js.map
