import React, { Children, createElement } from "react";

function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

var Element = 60103;

var Portal = 60106;

var Fragment = 60107;

var StrictMode = 60108;

var Profiler = 60114;

var ContextProvider = 60109;

var ContextConsumer = 60110;

var ConcurrentMode = 60111;

var ForwardRef = 60112;

var Suspense = 60113;

var Memo = 60115;

var Lazy = 60116;

var ClientReferenceTag = undefined;

if (typeof Symbol === "function" && Symbol.for) {
  var symbolFor = Symbol.for;
  Element = symbolFor("react.element");
  Portal = symbolFor("react.portal");
  Fragment = symbolFor("react.fragment");
  StrictMode = symbolFor("react.strict_mode");
  Profiler = symbolFor("react.profiler");
  ContextProvider = symbolFor("react.provider");
  ContextConsumer = symbolFor("react.context");
  ConcurrentMode = Symbol.for("react.concurrent_mode");
  ForwardRef = symbolFor("react.forward_ref");
  Suspense = symbolFor("react.suspense");
  Memo = symbolFor("react.memo");
  Lazy = symbolFor("react.lazy");
  ClientReferenceTag = Symbol.for("react.client.reference");
}

var REACT_ELEMENT_TYPE = Element;

var REACT_PORTAL_TYPE = Portal;

var REACT_FRAGMENT_TYPE = Fragment;

var REACT_STRICT_MODE_TYPE = StrictMode;

var REACT_PROFILER_TYPE = Profiler;

var REACT_PROVIDER_TYPE = ContextProvider;

var REACT_CONTEXT_TYPE = ContextConsumer;

var REACT_CONCURRENT_MODE_TYPE = ConcurrentMode;

var REACT_FORWARD_REF_TYPE = ForwardRef;

var REACT_SUSPENSE_TYPE = Suspense;

var REACT_MEMO_TYPE = Memo;

var REACT_LAZY_TYPE = Lazy;

var CLIENT_REFERENCE_TAG = ClientReferenceTag;

var shouldConstruct = function(Comp) {
  return Comp.prototype && Comp.prototype.isReactComponent;
};

var typeOf = function(x) {
  switch (x.$$typeof) {
   case REACT_PORTAL_TYPE:
    return REACT_PORTAL_TYPE;

   case REACT_ELEMENT_TYPE:
    switch (x.type) {
     case REACT_CONCURRENT_MODE_TYPE:
      return REACT_CONCURRENT_MODE_TYPE;

     case REACT_FRAGMENT_TYPE:
      return REACT_FRAGMENT_TYPE;

     case REACT_PROFILER_TYPE:
      return REACT_PROFILER_TYPE;

     case REACT_STRICT_MODE_TYPE:
      return REACT_STRICT_MODE_TYPE;

     case REACT_SUSPENSE_TYPE:
      return REACT_SUSPENSE_TYPE;

     default:
      {
        switch (x.type && x.type.$$typeof) {
         case REACT_LAZY_TYPE:
          return REACT_LAZY_TYPE;

         case REACT_MEMO_TYPE:
          return REACT_MEMO_TYPE;

         case REACT_CONTEXT_TYPE:
          return REACT_CONTEXT_TYPE;

         case REACT_PROVIDER_TYPE:
          return REACT_PROVIDER_TYPE;

         case REACT_FORWARD_REF_TYPE:
          return REACT_FORWARD_REF_TYPE;

         default:
          return REACT_ELEMENT_TYPE;
        }
      }
    }

   default:
    return undefined;
  }
};

var toArray = Children.toArray;

var isAbstractElement = function(node) {
  return node !== null && typeof node === "object";
};

var getChildrenArray = function(node) {
  return toArray(node).filter(isAbstractElement);
};

var computeProps = function(props, defaultProps) {
  return typeof defaultProps === "object" ? _extends({}, defaultProps, props) : props;
};

var currentContextStore = new Map;

var currentContextMap = {};

var prevContextMap = undefined;

var prevContextEntry = undefined;

var getCurrentContextMap = function() {
  return _extends({}, currentContextMap);
};

var getCurrentContextStore = function() {
  return new Map(currentContextStore);
};

var flushPrevContextMap = function() {
  var prev = prevContextMap;
  prevContextMap = undefined;
  return prev;
};

var flushPrevContextStore = function() {
  var prev = prevContextEntry;
  prevContextEntry = undefined;
  return prev;
};

var restoreContextMap = function(prev) {
  if (prev !== undefined) {
    _extends(currentContextMap, prev);
  }
};

var restoreContextStore = function(prev) {
  if (prev !== undefined) {
    currentContextStore.set(prev[0], prev[1]);
  }
};

var setCurrentContextMap = function(map) {
  prevContextMap = undefined;
  currentContextMap = map;
};

var setCurrentContextStore = function(store) {
  prevContextEntry = undefined;
  currentContextStore = store;
};

var assignContextMap = function(map) {
  prevContextMap = {};
  for (var name in map) {
    prevContextMap[name] = currentContextMap[name];
    currentContextMap[name] = map[name];
  }
};

var setContextValue = function(context, value) {
  prevContextEntry = [ context, currentContextStore.get(context) ];
  currentContextStore.set(context, value);
};

var readContextValue = function(context) {
  var value = currentContextStore.get(context);
  if (value !== undefined) {
    return value;
  }
  return context._currentValue;
};

var emptyContext = {};

var maskContext = function(type) {
  var contextType = type.contextType;
  var contextTypes = type.contextTypes;
  if (contextType) {
    return readContextValue(contextType);
  } else if (!contextTypes) {
    return emptyContext;
  }
  var maskedContext = {};
  for (var name in contextTypes) {
    maskedContext[name] = currentContextMap[name];
  }
  return maskedContext;
};

var currentErrorFrame = null;

var getCurrentErrorFrame = function() {
  return currentErrorFrame;
};

var setCurrentErrorFrame = function(frame) {
  currentErrorFrame = frame || null;
};

var rendererStateRef = {
  current: {
    uniqueID: 0
  }
};

var initRendererState = function() {
  return rendererStateRef.current = {
    uniqueID: 0
  };
};

var setCurrentRendererState = function(state) {
  return rendererStateRef.current = state;
};

function is(x, y) {
  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
}

var objectIs = typeof Object.is === "function" ? Object.is : is;

var is$1 = objectIs;

var currentIdentity = null;

var makeIdentity = function() {
  return {};
};

var setCurrentIdentity = function(id) {
  currentIdentity = id;
};

var getCurrentIdentity = function() {
  if (currentIdentity === null) {
    throw new Error("[react-ssr-prepass] Hooks can only be called inside the body of a function component. " + "(https://fb.me/react-invalid-hook-call)");
  }
  return currentIdentity;
};

var firstWorkInProgressHook = null;

var workInProgressHook = null;

var didScheduleRenderPhaseUpdate = false;

var renderPhaseUpdates = null;

var numberOfReRenders = 0;

var RE_RENDER_LIMIT$1 = 25;

var getFirstHook = function() {
  return firstWorkInProgressHook;
};

var setFirstHook = function(hook) {
  firstWorkInProgressHook = hook;
};

function areHookInputsEqual(nextDeps, prevDeps) {
  if (prevDeps === null) {
    return false;
  }
  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
    if (!is$1(nextDeps[i], prevDeps[i])) {
      return false;
    }
  }
  return true;
}

function createHook() {
  return {
    memoizedState: null,
    queue: null,
    next: null
  };
}

function createWorkInProgressHook() {
  if (workInProgressHook === null) {
    if (firstWorkInProgressHook === null) {
      return firstWorkInProgressHook = workInProgressHook = createHook();
    } else {
      return workInProgressHook = firstWorkInProgressHook;
    }
  } else {
    if (workInProgressHook.next === null) {
      return workInProgressHook = workInProgressHook.next = createHook();
    } else {
      return workInProgressHook = workInProgressHook.next;
    }
  }
}

function renderWithHooks(Component, props, refOrContext) {
  workInProgressHook = null;
  var children = Component(props, refOrContext);
  while (numberOfReRenders < RE_RENDER_LIMIT$1 && didScheduleRenderPhaseUpdate) {
    didScheduleRenderPhaseUpdate = false;
    numberOfReRenders += 1;
    workInProgressHook = null;
    children = Component(props, refOrContext);
  }
  numberOfReRenders = 0;
  renderPhaseUpdates = null;
  workInProgressHook = null;
  return children;
}

function readContext(context, _) {
  return readContextValue(context);
}

function useContext(context, _) {
  getCurrentIdentity();
  return readContextValue(context);
}

function basicStateReducer(state, action) {
  return typeof action === "function" ? action(state) : action;
}

function useState(initialState) {
  return useReducer(basicStateReducer, initialState);
}

function useReducer(reducer, initialArg, init) {
  var id = getCurrentIdentity();
  workInProgressHook = createWorkInProgressHook();
  if (workInProgressHook.queue === null) {
    var initialState;
    if (reducer === basicStateReducer) {
      initialState = typeof initialArg === "function" ? initialArg() : initialArg;
    } else {
      initialState = init !== undefined ? init(initialArg) : initialArg;
    }
    workInProgressHook.memoizedState = initialState;
  }
  var queue = workInProgressHook.queue || (workInProgressHook.queue = {
    last: null,
    dispatch: null
  });
  var dispatch = queue.dispatch || (queue.dispatch = dispatchAction.bind(null, id, queue));
  if (renderPhaseUpdates !== null) {
    var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
    if (firstRenderPhaseUpdate !== undefined) {
      renderPhaseUpdates.delete(queue);
      var newState = workInProgressHook.memoizedState;
      var update = firstRenderPhaseUpdate;
      do {
        var action = update.action;
        newState = reducer(newState, action);
        update = update.next;
      } while (update !== null);
      workInProgressHook.memoizedState = newState;
    }
  }
  return [ workInProgressHook.memoizedState, dispatch ];
}

function useMemo(nextCreate, deps) {
  getCurrentIdentity();
  workInProgressHook = createWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  var prevState = workInProgressHook.memoizedState;
  if (prevState !== null && nextDeps !== null) {
    var prevDeps = prevState[1];
    if (areHookInputsEqual(nextDeps, prevDeps)) {
      return prevState[0];
    }
  }
  var nextValue = nextCreate();
  workInProgressHook.memoizedState = [ nextValue, nextDeps ];
  return nextValue;
}

function useRef(initialValue) {
  getCurrentIdentity();
  workInProgressHook = createWorkInProgressHook();
  var previousRef = workInProgressHook.memoizedState;
  if (previousRef === null) {
    var ref = {
      current: initialValue
    };
    workInProgressHook.memoizedState = ref;
    return ref;
  } else {
    return previousRef;
  }
}

function useOpaqueIdentifier() {
  getCurrentIdentity();
  workInProgressHook = createWorkInProgressHook();
  if (!workInProgressHook.memoizedState) {
    workInProgressHook.memoizedState = "R:" + (rendererStateRef.current.uniqueID++).toString(36);
  }
  return workInProgressHook.memoizedState;
}

function dispatchAction(componentIdentity, queue, action) {
  if (componentIdentity === currentIdentity) {
    didScheduleRenderPhaseUpdate = true;
    var update = {
      action: action,
      next: null
    };
    if (renderPhaseUpdates === null) {
      renderPhaseUpdates = new Map;
    }
    var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
    if (firstRenderPhaseUpdate === undefined) {
      renderPhaseUpdates.set(queue, update);
    } else {
      var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
      while (lastRenderPhaseUpdate.next !== null) {
        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
      }
      lastRenderPhaseUpdate.next = update;
    }
  }
}

function useCallback(callback, deps) {
  return useMemo((function() {
    return callback;
  }), deps);
}

function useMutableSource(source, getSnapshot, _subscribe) {
  getCurrentIdentity();
  return getSnapshot(source._source);
}

function noop() {}

function _ref$3(callback) {
  callback();
}

function useTransition() {
  var startTransition = _ref$3;
  return [ startTransition, false ];
}

function useDeferredValue(input) {
  return input;
}

function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
  return getSnapshot();
}

var Dispatcher = {
  readContext: readContext,
  useSyncExternalStore: useSyncExternalStore,
  useContext: useContext,
  useMemo: useMemo,
  useReducer: useReducer,
  useRef: useRef,
  useState: useState,
  useCallback: useCallback,
  useMutableSource: useMutableSource,
  useTransition: useTransition,
  useDeferredValue: useDeferredValue,
  useOpaqueIdentifier: useOpaqueIdentifier,
  useId: useOpaqueIdentifier,
  unstable_useId: useOpaqueIdentifier,
  unstable_useOpaqueIdentifier: useOpaqueIdentifier,
  useLayoutEffect: noop,
  useImperativeHandle: noop,
  useEffect: noop,
  useDebugValue: noop,
  useInsertionEffect: noop,
  isPlasmicPrepass: true
};

var resolve = function(type) {
  var payload = type._payload || type;
  if (payload._status === 0) {
    return payload._result;
  } else if (payload._status === 1) {
    return Promise.resolve(payload._result);
  } else if (payload._status === 2) {
    return Promise.reject(payload._result);
  }
  payload._status = 0;
  return payload._result = (payload._ctor || payload._result)().then((function(Component) {
    payload._result = Component;
    if (typeof Component === "function") {
      payload._status = 1;
    } else if (Component !== null && typeof Component === "object" && typeof Component.default === "function") {
      payload._result = Component.default;
      payload._status = 1;
    } else {
      payload._status = 2;
    }
  })).catch((function(error) {
    payload._status = 2;
    payload._result = error;
    return Promise.reject(error);
  }));
};

var makeFrame$2 = function(type, props, thenable) {
  return {
    kind: "frame.lazy",
    contextMap: getCurrentContextMap(),
    contextStore: getCurrentContextStore(),
    errorFrame: getCurrentErrorFrame(),
    thenable: thenable,
    props: props,
    type: type
  };
};

var render$4 = function(type, props, queue) {
  var payload = type._payload || type;
  if (payload._status === 1 && payload._result) {
    return createElement(payload._result, props);
  }
  try {
    return createElement(type._init(type._payload), props);
  } catch (err) {
    if (!!err && typeof err.then === "function") {
      queue.push(makeFrame$2(type, props, err));
    }
    return null;
  }
};

var mount$3 = function(type, props, queue) {
  var payload = type._payload || type;
  if (payload._status != null && payload._status <= 0) {
    queue.push(makeFrame$2(type, props, resolve(type)));
    return null;
  }
  return render$4(type, props, queue);
};

var update$4 = function(queue, frame) {
  setCurrentIdentity(null);
  setCurrentContextMap(frame.contextMap);
  setCurrentContextStore(frame.contextStore);
  setCurrentErrorFrame(frame.errorFrame);
  return render$4(frame.type, frame.props, queue);
};

function isClientReference(reference) {
  return reference.$$typeof === CLIENT_REFERENCE_TAG;
}

var getComponentName = function(type) {
  if (isClientReference(type)) {
    return undefined;
  }
  if (type.displayName) {
    return type.displayName;
  }
  if (shouldConstruct(type)) {
    return type.constructor.name;
  } else {
    return type.name;
  }
};

var makeFrame$1 = function(type, props, thenable) {
  return {
    contextMap: getCurrentContextMap(),
    contextStore: getCurrentContextStore(),
    id: getCurrentIdentity(),
    hook: getFirstHook(),
    kind: "frame.hooks",
    errorFrame: getCurrentErrorFrame(),
    thenable: thenable,
    props: props,
    type: type
  };
};

var render$3 = function(type, props, queue) {
  try {
    return renderWithHooks(type, computeProps(props, type.defaultProps), maskContext(type));
  } catch (error) {
    if (typeof error.then !== "function") {
      console.warn("PLASMIC: Encountered error when pre-rendering " + getComponentName(type) + ": " + error);
      return null;
    }
    queue.push(makeFrame$1(type, props, error));
    return null;
  }
};

var mount$2 = function(type, props, queue, visitor, element) {
  setFirstHook(null);
  setCurrentIdentity(makeIdentity());
  var promise = visitor(element);
  if (promise) {
    queue.push(makeFrame$1(type, props, promise));
    return null;
  }
  return render$3(type, props, queue);
};

var update$3 = function(queue, frame) {
  setFirstHook(frame.hook);
  setCurrentIdentity(frame.id);
  setCurrentContextMap(frame.contextMap);
  setCurrentContextStore(frame.contextStore);
  setCurrentErrorFrame(frame.errorFrame);
  return render$3(frame.type, frame.props, queue);
};

var RE_RENDER_LIMIT = 25;

function _ref$2() {
  return false;
}

function _ref2$1() {
  return null;
}

var createUpdater = function() {
  var queue = [];
  return {
    _thrown: 0,
    queue: queue,
    isMounted: _ref$2,
    enqueueForceUpdate: _ref2$1,
    enqueueReplaceState: function(instance, completeState) {
      if (instance._isMounted) {
        queue.length = 0;
        queue.push(completeState);
      }
    },
    enqueueSetState: function(instance, currentPartialState) {
      if (instance._isMounted) {
        queue.push(currentPartialState);
      }
    }
  };
};

var flushEnqueuedState = function(instance) {
  var queue = instance.updater.queue;
  if (queue.length > 0) {
    var nextState = _extends({}, instance.state);
    for (var i = 0, l = queue.length; i < l; i++) {
      var partial = queue[i];
      var partialState = typeof partial === "function" ? partial.call(instance, nextState, instance.props, instance.context) : partial;
      if (partialState !== null) {
        _extends(nextState, partialState);
      }
    }
    instance.state = nextState;
    queue.length = 0;
  }
};

var createInstance = function(type, props) {
  var updater = createUpdater();
  var computedProps = computeProps(props, type.defaultProps);
  var context = maskContext(type);
  var instance = new type(computedProps, context, updater);
  instance.props = computedProps;
  instance.context = context;
  instance.updater = updater;
  instance._isMounted = true;
  if (instance.state === undefined) {
    instance.state = null;
  }
  if (typeof instance.componentDidCatch === "function" || typeof type.getDerivedStateFromError === "function") {
    var frame = makeFrame(type, instance, null);
    frame.errorFrame = frame;
    setCurrentErrorFrame(frame);
  }
  if (typeof type.getDerivedStateFromProps === "function") {
    var getDerivedStateFromProps = type.getDerivedStateFromProps;
    var state = getDerivedStateFromProps(instance.props, instance.state);
    if (state !== null && state !== undefined) {
      instance.state = _extends({}, instance.state, state);
    }
  } else if (typeof instance.componentWillMount === "function") {
    instance.componentWillMount();
  } else if (typeof instance.UNSAFE_componentWillMount === "function") {
    instance.UNSAFE_componentWillMount();
  }
  return instance;
};

var makeFrame = function(type, instance, thenable) {
  return {
    contextMap: getCurrentContextMap(),
    contextStore: getCurrentContextStore(),
    errorFrame: getCurrentErrorFrame(),
    thenable: thenable,
    kind: "frame.class",
    error: null,
    instance: instance,
    type: type
  };
};

var render$2 = function(type, instance, queue) {
  flushEnqueuedState(instance);
  var child = null;
  try {
    child = instance.render();
  } catch (error) {
    if (typeof error.then !== "function") {
      console.warn("PLASMIC: Encountered error when pre-rendering component " + getComponentName(type) + ". This is fine as long as you are not fetching data with @plasmicapp/query inside this component.  Error: " + error);
      return null;
    }
    queue.push(makeFrame(type, instance, error));
    return null;
  }
  if (type.childContextTypes !== undefined && typeof instance.getChildContext === "function") {
    var childContext = instance.getChildContext();
    if (childContext !== null && typeof childContext === "object") {
      assignContextMap(childContext);
    }
  }
  if (typeof instance.getDerivedStateFromProps !== "function" && (typeof instance.componentWillMount === "function" || typeof instance.UNSAFE_componentWillMount === "function") && typeof instance.componentWillUnmount === "function") {
    try {
      instance.componentWillUnmount();
    } catch (_err) {}
  }
  instance._isMounted = false;
  return child;
};

var mount$1 = function(type, props, queue, visitor, element) {
  setCurrentIdentity(null);
  var instance = createInstance(type, props);
  var promise = visitor(element, instance);
  if (promise) {
    queue.push(makeFrame(type, instance, promise));
    return null;
  }
  return render$2(type, instance, queue);
};

var update$2 = function(queue, frame) {
  setCurrentIdentity(null);
  setCurrentContextMap(frame.contextMap);
  setCurrentContextStore(frame.contextStore);
  setCurrentErrorFrame(frame.errorFrame);
  if (frame.error) {
    if (++frame.instance.updater._thrown >= RE_RENDER_LIMIT) {
      return null;
    }
    frame.instance._isMounted = true;
    if (typeof frame.instance.componentDidCatch === "function") {
      frame.instance.componentDidCatch(frame.error);
    }
    if (typeof frame.type.getDerivedStateFromError === "function") {
      frame.instance.updater.enqueueSetState(frame.instance, frame.type.getDerivedStateFromError(frame.error));
    }
  }
  return render$2(frame.type, frame.instance, queue);
};

function _ref$1(elt) {
  return elt && typeof elt === "object" && typeOf(elt);
}

var render$1 = function(type, props, queue, clientRefVisitor, element) {
  try {
    var node = clientRefVisitor(element);
    return createElement(React.Fragment, {}, [].concat(node ? getChildrenArray(node) : Object.values(props).flat(Infinity).filter(_ref$1)));
  } catch (error) {
    if (typeof error.then !== "function") {
      console.warn("PLASMIC: Encountered error when pre-rendering client reference: " + error);
      return null;
    }
    queue.push({
      contextMap: getCurrentContextMap(),
      contextStore: getCurrentContextStore(),
      errorFrame: getCurrentErrorFrame(),
      id: getCurrentIdentity(),
      hook: getFirstHook(),
      thenable: error,
      kind: "client-ref",
      type: type,
      props: props,
      element: element,
      clientRefVisitor: clientRefVisitor
    });
    return null;
  }
};

var mount = function(type, props, queue, clientRefVisitor, element) {
  setFirstHook(null);
  setCurrentIdentity(makeIdentity());
  return render$1(type, props, queue, clientRefVisitor, element);
};

var update$1 = function(queue, frame) {
  setFirstHook(frame.hook);
  setCurrentIdentity(frame.id);
  setCurrentContextMap(frame.contextMap);
  setCurrentContextStore(frame.contextStore);
  setCurrentErrorFrame(frame.errorFrame);
  return render$1(frame.type, frame.props, queue, frame.clientRefVisitor, frame.element);
};

var ref = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

var ReactCurrentDispatcher = ref.ReactCurrentDispatcher;

var SHOULD_YIELD = typeof setImmediate === "function";

var YIELD_AFTER_MS = 5;

var render = function(type, props, queue, visitor, clientRefVisitor, element) {
  if (isClientReference(type)) {
    return mount(type, props, queue, clientRefVisitor, element);
  }
  return shouldConstruct(type) ? mount$1(type, props, queue, visitor, element) : mount$2(type, props, queue, visitor, element);
};

var visitElement = function(element, queue, visitor, clientRefVisitor) {
  switch (typeOf(element)) {
   case REACT_SUSPENSE_TYPE:
   case REACT_STRICT_MODE_TYPE:
   case REACT_CONCURRENT_MODE_TYPE:
   case REACT_PROFILER_TYPE:
   case REACT_FRAGMENT_TYPE:
    {
      var fragmentElement = element;
      return getChildrenArray(fragmentElement.props.children);
    }

   case REACT_PROVIDER_TYPE:
    {
      var providerElement = element;
      var ref = providerElement.props;
      var value = ref.value;
      var children = ref.children;
      setContextValue(providerElement.type._context, value);
      return getChildrenArray(children);
    }

   case REACT_CONTEXT_TYPE:
    {
      var consumerElement = element;
      var ref$1 = consumerElement.props;
      var children$1 = ref$1.children;
      if (typeof children$1 === "function") {
        var type = consumerElement.type;
        var context = typeof type._context === "object" ? type._context : type;
        var value$1 = readContextValue(context);
        return getChildrenArray(children$1(value$1));
      } else {
        return [];
      }
    }

   case REACT_LAZY_TYPE:
    {
      var lazyElement = element;
      var type$1 = lazyElement.type;
      var child = mount$3(type$1, lazyElement.props, queue);
      return getChildrenArray(child);
    }

   case REACT_MEMO_TYPE:
    {
      var memoElement = element;
      var ref$2 = memoElement.type;
      var type$2 = ref$2.type;
      var child$1 = createElement(type$2, memoElement.props);
      return getChildrenArray(child$1);
    }

   case REACT_FORWARD_REF_TYPE:
    {
      var refElement = element;
      var ref$3 = refElement.type;
      var type$3 = ref$3.render;
      var defaultProps = ref$3.defaultProps;
      var props = computeProps(refElement.props, defaultProps);
      var child$2 = createElement(type$3, props);
      return getChildrenArray(child$2);
    }

   case REACT_ELEMENT_TYPE:
    {
      var el = element;
      if (typeof el.type === "string") {
        return getChildrenArray(el.props.children);
      } else {
        var userElement = element;
        var type$4 = userElement.type;
        var props$1 = userElement.props;
        var child$3 = render(type$4, props$1, queue, visitor, clientRefVisitor, userElement);
        return getChildrenArray(child$3);
      }
    }

   case REACT_PORTAL_TYPE:
   default:
    return [];
  }
};

var visitLoop = function(traversalChildren, traversalMap, traversalStore, traversalErrorFrame, queue, visitor, clientRefVisitor) {
  var prevDispatcher = ReactCurrentDispatcher.current;
  var start = Date.now();
  try {
    ReactCurrentDispatcher.current = Dispatcher;
    while (traversalChildren.length > 0) {
      var element = traversalChildren[traversalChildren.length - 1].shift();
      if (element !== undefined) {
        var children = visitElement(element, queue, visitor, clientRefVisitor);
        traversalChildren.push(children);
        traversalMap.push(flushPrevContextMap());
        traversalStore.push(flushPrevContextStore());
        traversalErrorFrame.push(getCurrentErrorFrame());
      } else {
        traversalChildren.pop();
        restoreContextMap(traversalMap.pop());
        restoreContextStore(traversalStore.pop());
        setCurrentErrorFrame(traversalErrorFrame.pop());
      }
      if (SHOULD_YIELD && Date.now() - start > YIELD_AFTER_MS) {
        return true;
      }
    }
    return false;
  } catch (error) {
    var errorFrame = getCurrentErrorFrame();
    if (!errorFrame) {
      throw error;
    }
    errorFrame.error = error;
    queue.unshift(errorFrame);
    return false;
  } finally {
    ReactCurrentDispatcher.current = prevDispatcher;
  }
};

var makeYieldFrame = function(traversalChildren, traversalMap, traversalStore, traversalErrorFrame) {
  return {
    contextMap: getCurrentContextMap(),
    contextStore: getCurrentContextStore(),
    errorFrame: getCurrentErrorFrame(),
    thenable: null,
    kind: "frame.yield",
    traversalChildren: traversalChildren,
    traversalMap: traversalMap,
    traversalStore: traversalStore,
    traversalErrorFrame: traversalErrorFrame
  };
};

var visit = function(init, queue, visitor, clientRefVisitor) {
  var traversalChildren = [ init ];
  var traversalMap = [ flushPrevContextMap() ];
  var traversalStore = [ flushPrevContextStore() ];
  var traversalErrorFrame = [ getCurrentErrorFrame() ];
  var hasYielded = visitLoop(traversalChildren, traversalMap, traversalStore, traversalErrorFrame, queue, visitor, clientRefVisitor);
  if (hasYielded) {
    queue.unshift(makeYieldFrame(traversalChildren, traversalMap, traversalStore, traversalErrorFrame));
  }
};

var update = function(frame, queue, visitor, clientRefVisitor) {
  if (frame.kind === "frame.yield") {
    setCurrentIdentity(null);
    setCurrentContextMap(frame.contextMap);
    setCurrentContextStore(frame.contextStore);
    setCurrentErrorFrame(frame.errorFrame);
    var hasYielded = visitLoop(frame.traversalChildren, frame.traversalMap, frame.traversalStore, frame.traversalErrorFrame, queue, visitor, clientRefVisitor);
    if (hasYielded) {
      queue.unshift(makeYieldFrame(frame.traversalChildren, frame.traversalMap, frame.traversalStore, frame.traversalErrorFrame));
    }
  } else {
    var prevDispatcher = ReactCurrentDispatcher.current;
    var children = null;
    ReactCurrentDispatcher.current = Dispatcher;
    try {
      if (frame.kind === "frame.class") {
        children = update$2(queue, frame);
      } else if (frame.kind === "frame.hooks") {
        children = update$3(queue, frame);
      } else if (frame.kind === "frame.lazy") {
        children = update$4(queue, frame);
      } else if (frame.kind === "client-ref") {
        children = update$1(queue, frame);
      }
    } catch (error) {
      var errorFrame = getCurrentErrorFrame();
      if (!errorFrame) {
        throw error;
      }
      errorFrame.error = error;
      queue.unshift(errorFrame);
      children = null;
    } finally {
      ReactCurrentDispatcher.current = prevDispatcher;
    }
    visit(getChildrenArray(children), queue, visitor, clientRefVisitor);
  }
};

function _ref(resolve, reject) {
  setImmediate(resolve);
}

var flushFrames = function(queue, visitor, clientRefVisitor, state) {
  var frame = queue.shift();
  if (!frame) {
    return Promise.resolve();
  }
  if (SHOULD_YIELD && frame.kind === "frame.yield") {
    frame.thenable = new Promise(_ref);
  }
  return Promise.resolve(frame.thenable).then((function() {
    setCurrentRendererState(state);
    update(frame, queue, visitor, clientRefVisitor);
    return flushFrames(queue, visitor, clientRefVisitor, state);
  }), (function(error) {
    if (!frame.errorFrame) {
      throw error;
    }
    frame.errorFrame.error = error;
    update(frame.errorFrame, queue, visitor, clientRefVisitor);
  }));
};

var defaultVisitor = function() {
  return undefined;
};

var runningPrepassCount = 0;

function _ref2() {
  runningPrepassCount--;
  if (!runningPrepassCount) {
    delete globalThis.__ssrPrepassEnv;
  }
}

var renderPrepass = function(element, visitor, clientRefVisitor) {
  if (!visitor) {
    visitor = defaultVisitor;
  }
  if (!clientRefVisitor) {
    clientRefVisitor = defaultVisitor;
  }
  var queue = [];
  var state = initRendererState();
  setCurrentContextMap({});
  setCurrentContextStore(new Map);
  setCurrentErrorFrame(null);
  try {
    runningPrepassCount++;
    globalThis.__ssrPrepassEnv = {
      readContextValue: readContextValue,
      setContextValue: setContextValue
    };
    visit(getChildrenArray(element), queue, visitor, clientRefVisitor);
  } catch (error) {
    runningPrepassCount--;
    if (!runningPrepassCount) {
      delete globalThis.__ssrPrepassEnv;
    }
    return Promise.reject(error);
  }
  return flushFrames(queue, visitor, clientRefVisitor, state).finally(_ref2);
};

export { renderPrepass as default };
//# sourceMappingURL=react-ssr-prepass.es.js.map
